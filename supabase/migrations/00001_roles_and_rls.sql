-- =============================================================================
-- Migration: 00001_roles_and_rls.sql
-- Purpose: Role-based access control infrastructure
-- =============================================================================
--
-- This migration creates the complete RBAC infrastructure for the YM Serving
-- System. It is meant to be run manually in the Supabase SQL Editor or via
-- the Supabase CLI. It is NOT auto-migrated by Next.js.
--
-- After running this migration, you must also:
--   1. Enable the custom access token hook in the Supabase Dashboard:
--      Authentication -> Hooks -> Enable "Custom access token" hook
--      -> Select public.custom_access_token_hook
--   2. Verify the hook is active by inspecting a user's JWT claims
--      for the "user_role" field.
--
-- Role hierarchy: admin > committee > member
-- =============================================================================


-- =============================================================================
-- Section 1: Role enum and user_roles table
-- =============================================================================

-- Role enum: admin > committee > member (hierarchy)
-- "committee" replaces "team lead" per user decision
create type public.app_role as enum ('admin', 'committee', 'member');

create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  role app_role not null default 'member',
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  unique (user_id, role)
);

-- Enable RLS
alter table public.user_roles enable row level security;


-- =============================================================================
-- Section 2: Custom access token hook
-- =============================================================================
-- This function is called by Supabase Auth every time a JWT is issued.
-- It embeds the user's role into the JWT claims so that:
--   - RLS policies can check roles without extra DB queries
--   - Client-side code can read the role from the session JWT
--   - Default role is 'member' if no role is found

create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
declare
  claims jsonb;
  user_role public.app_role;
begin
  -- Look up the user's role from the user_roles table
  select role into user_role
  from public.user_roles
  where user_id = (event->>'user_id')::uuid;

  claims := event->'claims';

  if user_role is not null then
    -- User has an assigned role
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  else
    -- Default to 'member' if no role is found
    claims := jsonb_set(claims, '{user_role}', '"member"');
  end if;

  event := jsonb_set(event, '{claims}', claims);
  return event;
end;
$$;


-- =============================================================================
-- Section 3: Grant permissions to supabase_auth_admin
-- =============================================================================
-- The auth admin role needs access to execute the hook and read user_roles.
-- We explicitly revoke access from other roles for security.

grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
  to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

-- Auth admin needs to read user_roles for the hook to work
create policy "Allow auth admin to read user roles"
  on public.user_roles
  as permissive for select
  to supabase_auth_admin
  using (true);


-- =============================================================================
-- Section 4: Role check helper functions
-- =============================================================================
-- These functions read the user's role from the JWT (no DB call).
-- Used in RLS policies throughout the application.

-- Exact role match: checks if the JWT user_role matches the required role
create or replace function public.has_role(required_role app_role)
returns boolean as $$
begin
  return (
    (select auth.jwt() ->> 'user_role')::public.app_role = required_role
  );
end;
$$ language plpgsql stable security definer set search_path = '';

-- Hierarchical role check: admin >= committee >= member
create or replace function public.has_role_or_higher(required_role app_role)
returns boolean as $$
declare
  current_role text;
begin
  current_role := (select auth.jwt() ->> 'user_role');

  -- Admin has access to everything
  if current_role = 'admin' then return true; end if;

  -- Committee has access to committee and member level
  if current_role = 'committee' and required_role in ('committee', 'member') then return true; end if;

  -- Member only has access to member level
  if current_role = 'member' and required_role = 'member' then return true; end if;

  return false;
end;
$$ language plpgsql stable security definer set search_path = '';


-- =============================================================================
-- Section 5: RLS policies on user_roles
-- =============================================================================

-- Admins can manage all roles (SELECT, INSERT, UPDATE, DELETE)
create policy "Admins can manage all roles"
  on public.user_roles for all
  to authenticated
  using ((select public.has_role('admin')));

-- Any authenticated user can read their own role
create policy "Users can read own role"
  on public.user_roles for select
  to authenticated
  using (user_id = (select auth.uid()));


-- =============================================================================
-- Section 6: Updated_at trigger
-- =============================================================================
-- Automatically update the updated_at column on any row change.

create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger on_user_roles_updated
  before update on public.user_roles
  for each row
  execute function public.handle_updated_at();
