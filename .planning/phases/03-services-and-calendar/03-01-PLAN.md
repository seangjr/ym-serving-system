---
phase: 03-services-and-calendar
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00005_services.sql
  - lib/services/schemas.ts
  - lib/services/queries.ts
  - lib/services/actions.ts
  - lib/services/recurrence.ts
autonomous: true

must_haves:
  truths:
    - "service_types table exists with 4 seeded types (sunday-morning, sunday-evening, wednesday, special-event) each having name, label, color, sort_order, is_active"
    - "services table exists with title, service_date (DATE), start_time (TIME), end_time, duration_minutes, service_type_id FK, rehearsal_date, rehearsal_time, rehearsal_notes, notes, recurrence_pattern_id FK, is_cancelled, created_by FK to members"
    - "service_recurrence_patterns table exists with frequency, day_of_week, service_type_id, start/end dates, start/end times, duration_minutes, title_template, created_by"
    - "RLS enabled on all 3 tables: authenticated users can SELECT; mutations go through admin client"
    - "Zod schemas validate create/update service, create recurring pattern, and service type inputs"
    - "Query functions return services by month range, upcoming services, service by ID, all service types, and basic stats"
    - "Server actions for createService, updateService, deleteService, duplicateService, createRecurringServices, createServiceType, updateServiceType, deleteServiceType all enforce admin/committee role"
    - "generateRecurringDates produces correct dates for weekly, biweekly, and monthly patterns capped at 52 instances"
  artifacts:
    - path: "supabase/migrations/00005_services.sql"
      provides: "service_types, services, service_recurrence_patterns tables with RLS and seed data"
      contains: "create table public.service_types"
    - path: "lib/services/schemas.ts"
      provides: "Zod validation schemas for all service inputs"
      exports: ["createServiceSchema", "updateServiceSchema", "createRecurringSchema", "serviceTypeSchema"]
    - path: "lib/services/queries.ts"
      provides: "Read-only query functions for services"
      exports: ["getServicesByMonth", "getUpcomingServices", "getServiceById", "getServiceTypes", "getServiceStats"]
    - path: "lib/services/actions.ts"
      provides: "Mutation server actions for services"
      exports: ["createService", "updateService", "deleteService", "duplicateService", "createRecurringServices", "createServiceType", "updateServiceType", "deleteServiceType"]
    - path: "lib/services/recurrence.ts"
      provides: "Pure date-fns recurring date generation"
      exports: ["generateRecurringDates"]
  key_links:
    - from: "lib/services/actions.ts"
      to: "lib/services/schemas.ts"
      via: "Zod safeParse validation"
      pattern: "safeParse"
    - from: "lib/services/actions.ts"
      to: "lib/services/recurrence.ts"
      via: "generateRecurringDates call in createRecurringServices"
      pattern: "generateRecurringDates"
    - from: "lib/services/queries.ts"
      to: "supabase service_types(id, name, color)"
      via: "Nested Supabase select on services"
      pattern: "service_types\\(id"
---

<objective>
Create the complete data foundation for Phase 3: database schema (3 tables with RLS), Zod validation schemas, query functions, server actions, and recurring date generation logic.

Purpose: Every UI plan in Phase 3 depends on this data layer. Services are the core scheduling entity that Phase 4 (assignments), Phase 6 (notifications), and Phase 7 (setlists) will build upon -- getting the schema right is critical.

Output: SQL migration applied to Supabase, plus lib/services/ module with schemas.ts, queries.ts, actions.ts, and recurrence.ts ready for UI consumption.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-services-and-calendar/03-RESEARCH.md
@lib/teams/actions.ts
@lib/teams/queries.ts
@lib/teams/schemas.ts
@supabase/migrations/00003_serving_teams.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for service_types, services, and service_recurrence_patterns</name>
  <files>supabase/migrations/00005_services.sql</files>
  <action>
Create SQL migration file `supabase/migrations/00005_services.sql` with the following tables:

**1. service_types table** (SERV-08: configurable service types):
- `id` uuid PK default gen_random_uuid()
- `name` text NOT NULL UNIQUE (slug: 'sunday-morning', 'wednesday', etc.)
- `label` text NOT NULL ('Sunday Morning', 'Wednesday', etc.)
- `color` text NOT NULL default '#6366f1' (hex color for calendar dots)
- `sort_order` int NOT NULL default 0
- `is_active` boolean NOT NULL default true
- `created_at` timestamptz NOT NULL default now()

Seed 4 default types:
- ('sunday-morning', 'Sunday Morning', '#6366f1', 1)
- ('sunday-evening', 'Sunday Evening', '#8b5cf6', 2)
- ('wednesday', 'Wednesday', '#22c55e', 3)
- ('special-event', 'Special Event', '#f59e0b', 4)

**2. services table** (SERV-01, SERV-06):
- `id` uuid PK default gen_random_uuid()
- `title` text NOT NULL
- `service_date` date NOT NULL (NOT timestamptz -- church operates in single timezone)
- `start_time` time NOT NULL
- `end_time` time (estimated end time, SERV-06)
- `duration_minutes` int (alternative to end_time)
- `service_type_id` uuid FK -> service_types(id) ON DELETE SET NULL
- `rehearsal_date` date (SERV-06)
- `rehearsal_time` time
- `rehearsal_notes` text (SERV-06)
- `notes` text
- `recurrence_pattern_id` uuid (FK added after patterns table)
- `is_cancelled` boolean NOT NULL default false
- `created_by` uuid FK -> members(id) ON DELETE SET NULL
- `created_at` timestamptz NOT NULL default now()
- `updated_at` timestamptz NOT NULL default now()

Create indexes: `idx_services_date` on service_date, `idx_services_type` on service_type_id.

**3. service_recurrence_patterns table** (SERV-05):
- `id` uuid PK default gen_random_uuid()
- `frequency` text NOT NULL CHECK (frequency in ('weekly', 'biweekly', 'monthly'))
- `day_of_week` int CHECK (day_of_week between 0 and 6) -- 0=Sunday
- `service_type_id` uuid FK -> service_types(id) ON DELETE SET NULL
- `start_date` date NOT NULL
- `end_date` date NOT NULL
- `start_time` time NOT NULL
- `end_time` time
- `duration_minutes` int
- `title_template` text (e.g., 'Sunday Morning Service')
- `created_by` uuid FK -> members(id) ON DELETE SET NULL
- `created_at` timestamptz NOT NULL default now()

Add FK from services.recurrence_pattern_id -> service_recurrence_patterns(id) ON DELETE SET NULL.

**4. RLS policies** (all 3 tables):
- Enable RLS on all tables
- SELECT policy for `authenticated` role with `using (true)` on all 3 tables
- No INSERT/UPDATE/DELETE policies (mutations go through admin client per established pattern)

**5. updated_at trigger** on services table:
- Use existing `public.update_updated_at_column()` function (created in prior migrations)
- `BEFORE UPDATE FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column()`
  </action>
  <verify>
Run `pnpm build` to confirm no TypeScript errors. Visually inspect the migration SQL for correct syntax. Confirm file exists at supabase/migrations/00005_services.sql.
  </verify>
  <done>Migration file exists with 3 tables, 4 seed types, indexes, RLS policies, and updated_at trigger. SQL is syntactically correct.</done>
</task>

<task type="auto">
  <name>Task 2: Service module -- Zod schemas, query functions, server actions, and recurrence logic</name>
  <files>
lib/services/schemas.ts
lib/services/queries.ts
lib/services/actions.ts
lib/services/recurrence.ts
  </files>
  <action>
Create the complete `lib/services/` module following the exact patterns from `lib/teams/` (actions.ts, queries.ts, schemas.ts).

**lib/services/schemas.ts:**
- `serviceTypeSchema`: name (1-50 chars, lowercase+hyphens regex `/^[a-z0-9-]+$/`), label (1-100), color (hex regex `/^#[0-9a-fA-F]{6}$/`)
- `createServiceSchema`: title (1-200, required), serviceDate (YYYY-MM-DD regex), startTime (HH:MM regex), endTime (HH:MM optional), durationMinutes (int 1-480 optional), serviceTypeId (uuid optional), rehearsalDate (YYYY-MM-DD optional), rehearsalTime (HH:MM optional), rehearsalNotes (max 1000 optional), notes (max 2000 optional)
- `updateServiceSchema`: createServiceSchema.partial().extend({ id: z.string().uuid() })
- `createRecurringSchema`: frequency (enum weekly/biweekly/monthly), startDate, endDate (YYYY-MM-DD), dayOfWeek (0-6 optional), startTime (HH:MM), endTime (HH:MM optional), durationMinutes (1-480 optional), serviceTypeId (uuid optional), titleTemplate (1-200)
- `duplicateServiceSchema`: sourceServiceId (uuid), targetDate (YYYY-MM-DD)
- Export all schemas and their inferred types: CreateServiceInput, UpdateServiceInput, CreateRecurringInput, DuplicateServiceInput

**lib/services/recurrence.ts:**
- `RecurrenceFrequency` type: "weekly" | "biweekly" | "monthly"
- `RecurrenceConfig` interface: { frequency, startDate (string YYYY-MM-DD), endDate (string YYYY-MM-DD) }
- `generateRecurringDates(config: RecurrenceConfig): Date[]` -- uses date-fns `parseISO`, `addWeeks`, `addMonths`, `isBefore`, `isEqual`
  - Loop from startDate to endDate, incrementing by frequency
  - Cap at 52 instances max (safety limit for 1 year)
  - Return array of Date objects

**lib/services/queries.ts:**
All functions use `createClient()` (RLS-protected reads). Follow the getTeams/getTeamWithMembers pattern.

- `getServicesByMonth(year: number, month: number)` -- query services WHERE service_date BETWEEN startOfMonth and endOfMonth, join service_types(id, name, label, color), order by service_date then start_time. Use date-fns `startOfMonth`/`endOfMonth` to compute boundaries. Format dates as YYYY-MM-DD strings for Supabase .gte/.lte filters.
- `getUpcomingServices(limit = 10)` -- query services WHERE service_date >= today AND is_cancelled = false, join service_types(id, name, label, color), order by service_date ASC, limit. Use `format(new Date(), 'yyyy-MM-dd')` for today's date.
- `getServiceById(serviceId: string)` -- query single service with service_types join. Return null if not found (use .maybeSingle()).
- `getServiceTypes()` -- query all service_types WHERE is_active = true, order by sort_order.
- `getServiceStats()` -- return object with: upcomingCount (services where service_date >= today and not cancelled), unassignedPositions (0 placeholder for Phase 4), pendingConfirmations (0 placeholder for Phase 4). Use `.select('id', { count: 'exact', head: true })` for efficient count.

**lib/services/actions.ts:**
All functions use `"use server"` directive, getUserRole + isAdminOrCommittee check, createAdminClient() for mutations, revalidatePath("/dashboard"). Follow the exact pattern from lib/teams/actions.ts.

- `createService(data: unknown)` -> { success: true, serviceId: string } | { error: string }. Parse with createServiceSchema. Insert into services with snake_case column mapping (serviceDate -> service_date, startTime -> start_time, etc.). Include created_by from memberId (from getUserRole).
- `updateService(data: unknown)` -> { success: true } | { error: string }. Parse with updateServiceSchema. Update by id.
- `deleteService(serviceId: string)` -> { success: true } | { error: string }. Validate uuid. Delete by id.
- `duplicateService(data: unknown)` -> { success: true, serviceId: string } | { error: string }. Parse with duplicateServiceSchema. Fetch source service by sourceServiceId. Insert new service with same fields but targetDate as service_date. Do NOT copy recurrence_pattern_id. Add TODO comment: "// Phase 4: Also copy assignments. Phase 7: Also copy setlist items."
- `createRecurringServices(data: unknown)` -> { success: true, count: number } | { error: string }. Parse with createRecurringSchema. Call generateRecurringDates to get dates. Insert pattern row into service_recurrence_patterns. Bulk insert services (one per generated date) with recurrence_pattern_id set. Return count of created services.
- `createServiceType(data: unknown)` -> { success: true } | { error: string }. Parse with serviceTypeSchema. Check isAdmin (not committee -- only admin can manage types).
- `updateServiceType(data: unknown)` -> { success: true } | { error: string }. Extend serviceTypeSchema with id. isAdmin check.
- `deleteServiceType(serviceTypeId: string)` -> { success: true } | { error: string }. isAdmin check. Delete by id.

Important patterns to follow (from lib/teams/actions.ts):
- Use Zod v4 `.issues` (not `.errors`) on safeParse failure
- All error returns use `{ error: string }` format
- revalidatePath on success
- createAdminClient() for all writes
- getUserRole returns { role, memberId } -- use memberId for created_by
  </action>
  <verify>
Run `pnpm build` -- must compile without TypeScript errors. Run `pnpm lint` -- must pass with no errors on new files. Verify all exported functions exist: check that schemas.ts exports 5 schemas, queries.ts exports 5 functions, actions.ts exports 8 functions, recurrence.ts exports generateRecurringDates.
  </verify>
  <done>
All 4 lib/services/ files exist and compile. Schemas validate service inputs correctly. Query functions use RLS client with month-scoped and upcoming queries. Server actions enforce role authorization and use admin client for mutations. Recurring date generation works for weekly/biweekly/monthly with 52-instance cap. `pnpm build` and `pnpm lint` pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with zero TypeScript errors
2. `pnpm lint` passes with no errors on lib/services/* files
3. supabase/migrations/00005_services.sql contains CREATE TABLE for service_types, services, service_recurrence_patterns
4. lib/services/schemas.ts exports createServiceSchema, updateServiceSchema, createRecurringSchema, serviceTypeSchema, duplicateServiceSchema
5. lib/services/queries.ts exports getServicesByMonth, getUpcomingServices, getServiceById, getServiceTypes, getServiceStats
6. lib/services/actions.ts exports createService, updateService, deleteService, duplicateService, createRecurringServices, createServiceType, updateServiceType, deleteServiceType
7. lib/services/recurrence.ts exports generateRecurringDates
8. All server actions include getUserRole + isAdminOrCommittee (or isAdmin for type management) authorization checks
</verification>

<success_criteria>
- Migration file contains 3 tables with correct column types (date, time, uuid FKs), RLS policies, indexes, seed data, and updated_at trigger
- All lib/services/ files compile and follow established patterns from lib/teams/
- Server actions enforce role-based authorization and use admin client for writes
- Query functions use RLS client for reads with appropriate filters and joins
- Recurring date generation caps at 52 instances and handles weekly/biweekly/monthly
</success_criteria>

<output>
After completion, create `.planning/phases/03-services-and-calendar/03-01-SUMMARY.md`
</output>
