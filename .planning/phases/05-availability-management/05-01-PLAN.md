---
phase: 05-availability-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00008_availability.sql
  - lib/availability/types.ts
  - lib/availability/schemas.ts
  - lib/availability/recurrence.ts
  - lib/availability/queries.ts
  - lib/availability/actions.ts
  - lib/auth/roles.ts
autonomous: true

must_haves:
  truths:
    - "member_blackout_dates and member_recurring_unavailability tables exist with correct columns, constraints, and RLS"
    - "Blackout dates can be created, queried, and deleted through server actions with role-based authorization"
    - "Recurring patterns can be created, queried, and deleted through server actions"
    - "Recurring pattern matcher correctly identifies whether a target date matches a weekly, biweekly, monthly, or nth_weekday pattern"
    - "getUnavailableMembersForDate returns a map of unavailable member IDs with reasons for a given date"
    - "Sidebar navigation includes Availability link for all roles"
  artifacts:
    - path: "supabase/migrations/00008_availability.sql"
      provides: "Two availability tables with RLS, indexes, and updated_at triggers"
      contains: "member_blackout_dates"
    - path: "lib/availability/types.ts"
      provides: "TypeScript interfaces for blackout dates, recurring patterns, and availability data"
      exports: ["BlackoutDate", "RecurringPattern", "UnavailableMember"]
    - path: "lib/availability/schemas.ts"
      provides: "Zod validation schemas for all availability inputs"
      exports: ["addBlackoutSchema", "addBlackoutRangeSchema", "createRecurringPatternSchema", "deleteBlackoutSchema", "deleteRecurringPatternSchema"]
    - path: "lib/availability/recurrence.ts"
      provides: "Pure functions for matching dates against recurring patterns and expanding patterns into date sets"
      exports: ["matchesRecurringPattern", "expandRecurringPatterns"]
    - path: "lib/availability/queries.ts"
      provides: "Query functions for blackouts, recurring patterns, and unavailability checks"
      exports: ["getMyBlackouts", "getMyRecurringPatterns", "getMemberBlackouts", "getMemberRecurringPatterns", "getUnavailableMembersForDate", "getTeamAvailability"]
    - path: "lib/availability/actions.ts"
      provides: "Server actions for CRUD on blackout dates and recurring patterns with authorization"
      exports: ["addBlackoutDate", "addBlackoutRange", "deleteBlackout", "createRecurringPattern", "deleteRecurringPattern"]
    - path: "lib/auth/roles.ts"
      provides: "Updated sidebar navigation with Availability item"
      contains: "Availability"
  key_links:
    - from: "lib/availability/actions.ts"
      to: "lib/availability/schemas.ts"
      via: "Zod validation in each server action"
      pattern: "safeParse"
    - from: "lib/availability/queries.ts"
      to: "lib/availability/recurrence.ts"
      via: "expandRecurringPatterns called for date range queries"
      pattern: "expandRecurringPatterns"
    - from: "lib/availability/actions.ts"
      to: "lib/supabase/admin.ts"
      via: "createAdminClient for mutations"
      pattern: "createAdminClient"
---

<objective>
Create the availability database schema and complete lib/availability module with all types, validation schemas, recurrence logic, query functions, and server actions. Also add the Availability sidebar nav item.

Purpose: Foundation for both the availability management UI (Plan 02) and scheduling integration (Plan 03). Without tables and server actions, neither UI nor scheduling warnings can function.

Output: Two DB tables with RLS, a complete lib/availability module (types, schemas, recurrence, queries, actions), and updated sidebar navigation.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-availability-management/05-RESEARCH.md

# Key existing patterns to follow:
@supabase/migrations/00006_assignments.sql
@lib/assignments/types.ts
@lib/assignments/schemas.ts
@lib/assignments/queries.ts
@lib/assignments/actions.ts
@lib/services/recurrence.ts
@lib/auth/roles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration and lib/availability module (types, schemas, recurrence)</name>
  <files>
    supabase/migrations/00008_availability.sql
    lib/availability/types.ts
    lib/availability/schemas.ts
    lib/availability/recurrence.ts
  </files>
  <action>
**Migration (00008_availability.sql):**
Follow the pattern in 00006_assignments.sql exactly. Create two tables:

1. `member_blackout_dates`:
   - `id` uuid PK default gen_random_uuid()
   - `member_id` uuid NOT NULL references members(id) on delete cascade
   - `start_date` date NOT NULL
   - `end_date` date NOT NULL (same as start_date for single-day blackouts)
   - `reason` text (nullable, optional free-text visible to team leads)
   - `created_by` uuid references members(id) on delete set null (NULL = self-created, non-null = team lead set it)
   - `created_at` timestamptz NOT NULL default now()
   - CHECK constraint: `end_date >= start_date`
   - Index on (member_id, start_date, end_date)

2. `member_recurring_unavailability`:
   - `id` uuid PK default gen_random_uuid()
   - `member_id` uuid NOT NULL references members(id) on delete cascade
   - `frequency` text NOT NULL CHECK (in ('weekly', 'biweekly', 'monthly', 'nth_weekday'))
   - `day_of_week` int NOT NULL CHECK (between 0 and 6) -- 0=Sunday, 6=Saturday (JS convention)
   - `nth_occurrence` int CHECK (between 1 and 5) -- Only for nth_weekday; 5 = last occurrence
   - `start_date` date NOT NULL
   - `end_date` date (nullable -- NULL = ongoing, no end date)
   - `reason` text (nullable)
   - `created_by` uuid references members(id) on delete set null
   - `created_at` timestamptz NOT NULL default now()
   - `updated_at` timestamptz NOT NULL default now()
   - Index on (member_id)

RLS: Enable on both tables. Add SELECT policy for `authenticated` using `(true)` on both (everyone can view for team overlay and scheduling). Mutations via server actions with createAdminClient().

Add `updated_at` trigger on `member_recurring_unavailability` using existing `update_updated_at_column()` function.

**types.ts:** Create TypeScript interfaces following lib/assignments/types.ts pattern:
- `BlackoutDate` — id, memberId, startDate, endDate, reason, createdBy, createdAt
- `RecurringPattern` — id, memberId, frequency (union type), dayOfWeek, nthOccurrence, startDate, endDate, reason, createdBy, createdAt
- `UnavailableMember` — memberId, memberName, reason, type ('blackout' | 'recurring')
- `RecurringFrequency` — 'weekly' | 'biweekly' | 'monthly' | 'nth_weekday'
- `TeamDateAvailability` — date (string), total (number), available (number), unavailableMembers (UnavailableMember[])

**schemas.ts:** Create Zod v4 schemas following lib/assignments/schemas.ts pattern:
- `addBlackoutSchema` — memberId (optional uuid, null = self), startDate (YYYY-MM-DD string), endDate (optional, defaults to startDate), reason (optional string)
- `addBlackoutRangeSchema` — memberId (optional), startDate, endDate (required, must be >= startDate), reason (optional)
- `createRecurringPatternSchema` — memberId (optional), frequency (enum), dayOfWeek (0-6), nthOccurrence (optional, 1-5, required when frequency = 'nth_weekday'), startDate, endDate (optional), reason (optional)
- `deleteBlackoutSchema` — blackoutId (uuid)
- `deleteRecurringPatternSchema` — patternId (uuid)

Use `z.string().regex(/^\d{4}-\d{2}-\d{2}$/)` for date validation (matching existing service schema pattern).

**recurrence.ts:** Pure functions for recurring pattern matching (no DB, no server code):

1. `matchesRecurringPattern(date: Date, pattern: { frequency, day_of_week, nth_occurrence, start_date, end_date })`: Returns boolean. Logic per frequency type:
   - `weekly`: check getDay(date) === pattern.day_of_week
   - `biweekly`: check day_of_week match + differenceInWeeks(date, parseISO(start_date)) % 2 === 0
   - `monthly`: check getDate(date) === getDate(parseISO(start_date)) + day_of_week match
   - `nth_weekday`: check day_of_week + getNthOccurrenceInMonth(date) === nth_occurrence (5 = last)

2. `expandRecurringPatterns(patterns: RecurringPatternRow[], rangeStart: Date, rangeEnd: Date)`: Expands all patterns into a Map<string, Set<string>> (dateString -> Set of member IDs). Iterates each day in range, checks each pattern with matchesRecurringPattern. Cap expansion at 6 months or 184 days maximum for safety.

3. Helper `getNthOccurrenceInMonth(date: Date)`: Returns 1-5 based on Math.ceil(getDate(date) / 7).

4. Helper `isLastOccurrenceInMonth(date: Date)`: Returns true if adding 7 days puts us in the next month.

Import from `date-fns`: differenceInWeeks, getDay, getDate, getMonth, addDays, parseISO, eachDayOfInterval, format.
  </action>
  <verify>
    Run `pnpm build` to confirm TypeScript compiles. Verify the migration file has correct SQL syntax by reading it. Verify recurrence.ts exports are importable from queries.ts.
  </verify>
  <done>
    Migration file exists with both tables, RLS, indexes, and trigger. types.ts exports all interfaces. schemas.ts exports all Zod schemas. recurrence.ts exports matchesRecurringPattern and expandRecurringPatterns as pure functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Query functions, server actions, and sidebar nav update</name>
  <files>
    lib/availability/queries.ts
    lib/availability/actions.ts
    lib/auth/roles.ts
  </files>
  <action>
**queries.ts:** Follow lib/assignments/queries.ts pattern (uses RLS client for reads):

1. `getMyBlackouts(memberId: string)`: Fetch all blackout dates for a member, ordered by start_date desc. Returns BlackoutDate[].

2. `getMyRecurringPatterns(memberId: string)`: Fetch all recurring patterns for a member, ordered by created_at desc. Returns RecurringPattern[].

3. `getMemberBlackouts(memberId: string)`: Same as getMyBlackouts but for viewing another member's data (same query, different semantic — both are SELECT with RLS).

4. `getMemberRecurringPatterns(memberId: string)`: Same as getMyRecurringPatterns for another member.

5. `getUnavailableMembersForDate(memberIds: string[], serviceDate: string)`: The critical batch query. Returns `Map<string, { reason: string | null; type: 'blackout' | 'recurring' }>`. Steps:
   - Query member_blackout_dates WHERE member_id IN memberIds AND start_date <= serviceDate AND end_date >= serviceDate
   - Query member_recurring_unavailability WHERE member_id IN memberIds AND start_date <= serviceDate (and end_date is NULL or >= serviceDate)
   - For recurring patterns, call matchesRecurringPattern(parseISO(serviceDate), pattern) for each
   - Build and return the map. Blackout takes precedence over recurring for same member.

6. `getTeamAvailability(teamId: string, monthStart: string, monthEnd: string)`: For team overlay calendar. Steps:
   - Get all team members from team_members WHERE team_id
   - Get all blackouts for those members in date range
   - Get all recurring patterns for those members
   - Expand recurring patterns for the month range using expandRecurringPatterns()
   - Build TeamDateAvailability[] for each day in the range

**actions.ts:** Follow lib/assignments/actions.ts pattern exactly (server actions with "use server", Zod validation, getUserRole auth, createAdminClient for mutations):

1. `addBlackoutDate(data)`: Validate with addBlackoutSchema. If memberId provided and != callerId, check team lead authorization using canManageTeamAssignments pattern (admin/committee always allowed, team lead checks team_members). Insert into member_blackout_dates. revalidatePath('/availability').

2. `addBlackoutRange(data)`: Same as addBlackoutDate but uses addBlackoutRangeSchema with required endDate. Same authorization logic.

3. `deleteBlackout(data)`: Validate with deleteBlackoutSchema. Fetch the blackout to check member_id. If blackout.member_id != callerId, require admin/committee or team lead auth. Delete from member_blackout_dates. revalidatePath('/availability').

4. `createRecurringPattern(data)`: Validate with createRecurringPatternSchema. Same authorization as addBlackoutDate for setting on behalf of others. Insert into member_recurring_unavailability. revalidatePath('/availability').

5. `deleteRecurringPattern(data)`: Same authorization logic as deleteBlackout. Delete from member_recurring_unavailability. revalidatePath('/availability').

All actions return `{ success: true } | { error: string }`.

**Sidebar nav (lib/auth/roles.ts):** Add "Availability" nav item:
- In `ADMIN_NAV_ITEMS`: Add `{ title: "Availability", href: "/availability", icon: "CalendarOff" }` after "Team Roster" and before "Songs"
- In `MEMBER_NAV_ITEMS`: Add `{ title: "Availability", href: "/availability", icon: "CalendarOff" }` after "My Schedule" and before "Songs"
  </action>
  <verify>
    Run `pnpm build` to confirm TypeScript compiles with no errors. Run `pnpm lint` to check Biome formatting. Verify sidebar nav items have Availability in correct position by reading roles.ts.
  </verify>
  <done>
    queries.ts exports all 6 query functions. actions.ts exports all 5 server actions with proper authorization. Sidebar nav has "Availability" item with CalendarOff icon for both admin/committee and member roles. `pnpm build` passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with zero TypeScript errors
2. `pnpm lint` passes with no Biome issues
3. Migration file contains both tables with all columns, constraints, RLS policies, indexes, and trigger
4. lib/availability/ has 5 files: types.ts, schemas.ts, recurrence.ts, queries.ts, actions.ts
5. Sidebar navigation shows "Availability" link for admin, committee, and member roles
6. All server actions use "use server" directive, Zod validation, getUserRole auth check, and createAdminClient for mutations
7. recurrence.ts is a pure module with no server/DB dependencies (can be imported in client components)
</verification>

<success_criteria>
- Database migration ready to apply (00008_availability.sql)
- Complete lib/availability module with types, schemas, recurrence logic, queries, and actions
- Sidebar nav updated for all roles
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-availability-management/05-01-SUMMARY.md`
</output>
