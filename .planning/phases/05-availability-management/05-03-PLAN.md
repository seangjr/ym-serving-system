---
phase: 05-availability-management
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - lib/assignments/types.ts
  - lib/assignments/queries.ts
  - lib/assignments/actions.ts
  - lib/assignments/schemas.ts
  - app/(app)/services/[serviceId]/assignment-slot.tsx
  - app/(app)/services/[serviceId]/conflict-dialog.tsx
  - app/(app)/services/[serviceId]/availability-banner.tsx
  - app/(app)/services/[serviceId]/page.tsx
autonomous: true

must_haves:
  truths:
    - "When a member is unavailable on the service date, their combobox entry shows a warning icon (CalendarOff) alongside their name"
    - "Selecting an unavailable member triggers an 'Assign anyway?' confirmation dialog showing the unavailability reason"
    - "Unavailable members stay in alphabetical sort position in the dropdown (not moved or hidden)"
    - "Service detail page shows an availability banner at top: 'N members unavailable on this date' with expandable list"
    - "The assignMember server action checks availability and returns unavailability info when forceAssign is false"
    - "Force-assigning an unavailable member succeeds and creates the assignment"
  artifacts:
    - path: "lib/assignments/types.ts"
      provides: "Extended EligibleMember with isUnavailable and unavailabilityReason fields"
      contains: "isUnavailable"
    - path: "lib/assignments/queries.ts"
      provides: "getEligibleMembers now pre-computes unavailability data alongside conflict data"
      contains: "getUnavailableMembersForDate"
    - path: "lib/assignments/actions.ts"
      provides: "assignMember now returns { unavailable: UnavailabilityInfo } when member is unavailable"
      contains: "unavailable"
    - path: "app/(app)/services/[serviceId]/availability-banner.tsx"
      provides: "Expandable banner showing unavailable member count and details"
      contains: "AvailabilityBanner"
    - path: "app/(app)/services/[serviceId]/assignment-slot.tsx"
      provides: "Combobox items with unavailability warning icon and confirmation dialog"
      contains: "CalendarOff"
    - path: "app/(app)/services/[serviceId]/page.tsx"
      provides: "Service detail page with availability banner integrated"
      contains: "AvailabilityBanner"
  key_links:
    - from: "lib/assignments/queries.ts"
      to: "lib/availability/queries.ts"
      via: "getUnavailableMembersForDate called in getEligibleMembers"
      pattern: "getUnavailableMembersForDate"
    - from: "lib/assignments/actions.ts"
      to: "lib/availability/queries.ts"
      via: "Availability check before assignment in assignMember"
      pattern: "getUnavailableMembersForDate"
    - from: "app/(app)/services/[serviceId]/assignment-slot.tsx"
      to: "app/(app)/services/[serviceId]/conflict-dialog.tsx"
      via: "UnavailabilityDialog reuses ConflictDialog pattern for Assign Anyway flow"
      pattern: "UnavailabilityDialog"
---

<objective>
Integrate availability data into the scheduling workflow: extend getEligibleMembers with unavailability flags, add availability warnings in the assignment combobox, create "Assign anyway?" confirmation for unavailable members, and add availability banner to the service detail page.

Purpose: This completes AVAIL-03 -- when scheduling, unavailable dates surface as warnings and the system flags the conflict before confirming. This is the last piece connecting availability data to the scheduling UI.

Output: Updated assignment module with availability integration, warning icons in combobox, confirmation dialog, and availability banner on service detail page.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-availability-management/05-RESEARCH.md
@.planning/phases/05-availability-management/05-01-SUMMARY.md

# Files being modified:
@lib/assignments/types.ts
@lib/assignments/queries.ts
@lib/assignments/actions.ts
@lib/assignments/schemas.ts
@app/(app)/services/[serviceId]/assignment-slot.tsx
@app/(app)/services/[serviceId]/conflict-dialog.tsx
@app/(app)/services/[serviceId]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend assignment module with availability data (types, queries, actions)</name>
  <files>
    lib/assignments/types.ts
    lib/assignments/queries.ts
    lib/assignments/actions.ts
    lib/assignments/schemas.ts
  </files>
  <action>
**types.ts — Extend EligibleMember:**
Add two fields to the existing EligibleMember interface:
```typescript
isUnavailable: boolean;
unavailabilityReason: string | null;
```

Add a new interface:
```typescript
export interface UnavailabilityInfo {
  memberName: string;
  reason: string | null;
  type: 'blackout' | 'recurring';
}
```

**queries.ts — Extend getEligibleMembers:**
After step 4 (build conflict map) and before step 5 (fetch position skills), add a new step:

Step 4.5: Check availability for all team members on the service date.
```typescript
// Import from availability module
import { getUnavailableMembersForDate } from "@/lib/availability/queries";

// In getEligibleMembers(), after building conflictMap:
const unavailableMap = await getUnavailableMembersForDate(memberIds, targetService.service_date);
```

In step 6 (map to EligibleMember[]), add the unavailability fields:
```typescript
const unavailability = unavailableMap.get(memberId);
return {
  id: memberId,
  fullName: members?.full_name ?? "Unknown",
  hasConflict: !!conflict,
  conflictDetails: conflict ?? null,
  isUnavailable: !!unavailability,                    // NEW
  unavailabilityReason: unavailability?.reason ?? null, // NEW
  positionIds: positionSkillMap.get(memberId) ?? [],
};
```

Also add a new query function `getUnavailableMembersForService(serviceId: string)` that:
1. Fetches the service date
2. Gets all team member IDs across all teams that have positions on this service (query service_positions -> team_members)
3. Calls getUnavailableMembersForDate with those member IDs and the service date
4. Joins with member names from members table
5. Returns `UnavailableMember[]` for the availability banner (includes memberName)

This is for the banner at the top of the service detail page.

**actions.ts — Extend assignMember:**
The current assignMember returns `{ success } | { error } | { conflict }`. Extend to also return `{ unavailable: UnavailabilityInfo }`.

After the existing conflict check block, before the insert, add:
```typescript
// Check availability
const unavailableMap = await getUnavailableMembersForDate(
  [parsed.data.memberId],
  /* need service date - fetch it */
);

// Get service date for availability check
const { data: serviceForDate } = await admin
  .from("services")
  .select("service_date")
  .eq("id", parsed.data.serviceId)
  .single();

if (serviceForDate) {
  const unavailableMap = await getUnavailableMembersForDate(
    [parsed.data.memberId],
    serviceForDate.service_date,
  );
  const unavailability = unavailableMap.get(parsed.data.memberId);

  if (unavailability && !parsed.data.forceAssign) {
    // Get member name for dialog
    const { data: memberData } = await admin
      .from("members")
      .select("full_name")
      .eq("id", parsed.data.memberId)
      .single();

    return {
      unavailable: {
        memberName: memberData?.full_name ?? "Unknown",
        reason: unavailability.reason,
        type: unavailability.type,
      },
    };
  }
}
```

Update the return type of assignMember to include `| { unavailable: UnavailabilityInfo }`.

**Important ordering:** Check conflicts FIRST, then availability. If both conflict AND unavailable, the conflict dialog takes precedence (it already exists and the user expects it). After force-assigning past a conflict, the next call will check availability. OR: if the member has no conflict but IS unavailable, show unavailability dialog.

Actually, a cleaner approach: check both simultaneously. If conflict exists and !forceAssign, return conflict (existing behavior). If no conflict but unavailable and !forceAssign, return unavailable. If forceAssign is true, skip both checks and assign directly (forceAssign already covers both).

**schemas.ts — No changes needed:** The existing assignMemberSchema already has `forceAssign` as an optional boolean, which covers both conflict and unavailability force-assign.
  </action>
  <verify>
    Run `pnpm build` to confirm TypeScript compiles. Verify that getEligibleMembers now returns isUnavailable and unavailabilityReason fields. Verify assignMember can return { unavailable: ... }.
  </verify>
  <done>
    EligibleMember has isUnavailable and unavailabilityReason fields. getEligibleMembers pre-computes unavailability. assignMember returns { unavailable } when member is unavailable and forceAssign is false. getUnavailableMembersForService provides data for the banner.
  </done>
</task>

<task type="auto">
  <name>Task 2: Assignment slot warnings, unavailability dialog, and availability banner</name>
  <files>
    app/(app)/services/[serviceId]/assignment-slot.tsx
    app/(app)/services/[serviceId]/conflict-dialog.tsx
    app/(app)/services/[serviceId]/availability-banner.tsx
    app/(app)/services/[serviceId]/page.tsx
  </files>
  <action>
**assignment-slot.tsx — Add unavailability warning to combobox:**

1. Import CalendarOff from lucide-react
2. In the combobox dropdown (ComboboxItem), add unavailability icon alongside existing conflict icon:
```tsx
<ComboboxItem key={member.id} value={member.id}>
  <span className="flex items-center gap-1.5">
    {member.fullName}
    {member.hasConflict && (
      <AlertTriangle className="size-3.5 text-amber-500" />
    )}
    {member.isUnavailable && (
      <Tooltip>
        <TooltipTrigger asChild>
          <CalendarOff className="size-3.5 text-red-400" />
        </TooltipTrigger>
        <TooltipContent>
          Unavailable{member.unavailabilityReason ? `: ${member.unavailabilityReason}` : ''}
        </TooltipContent>
      </Tooltip>
    )}
  </span>
</ComboboxItem>
```

**Important:** Unavailable members keep same alphabetical sort position (per locked decision). Do NOT filter or re-sort them.

3. Handle the unavailability response from assignMember. In `handleAssign`, after the existing `if ("conflict" in result)` block, add:
```typescript
if ("unavailable" in result) {
  setPendingUnavailability({
    info: result.unavailable,
    memberId,
    memberName: member.fullName,
  });
  setUnavailabilityDialogOpen(true);
  return;
}
```

4. Add state for unavailability dialog:
```typescript
const [unavailabilityDialogOpen, setUnavailabilityDialogOpen] = useState(false);
const [pendingUnavailability, setPendingUnavailability] = useState<{
  info: UnavailabilityInfo;
  memberId: string;
  memberName: string;
} | null>(null);
```

5. Add `handleForceAssignUnavailable` callback (same as handleForceAssign but for unavailability).

6. In the assigned state render, add an unavailability indicator alongside the existing conflict warning icon. If the member's isUnavailable is true from the eligibleMembers data, show a CalendarOff icon with tooltip. (Note: assignment slot shows the assigned member from position.assignment, but the eligibleMembers list carries the unavailability flag. Pass isUnavailable/reason as extra props or look up from eligibleMembers.)

**conflict-dialog.tsx — Create UnavailabilityDialog:**
Create a new `UnavailabilityDialog` component in the same file (or a new unavailability-dialog.tsx file). Follow the exact same pattern as ConflictDialog:

```tsx
interface UnavailabilityDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  unavailability: UnavailabilityInfo | null;
  memberName: string;
  onConfirm: () => void;
  isPending: boolean;
}

export function UnavailabilityDialog({ ... }) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Member Unavailable</AlertDialogTitle>
          <AlertDialogDescription>
            {memberName} has marked this date as unavailable
            {unavailability?.reason ? `: "${unavailability.reason}"` : '.'}{' '}
            Assign anyway?
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isPending}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            disabled={isPending}
            className="bg-amber-600 text-white hover:bg-amber-700 ..."
          >
            {isPending ? "Assigning..." : "Assign Anyway"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```

**availability-banner.tsx (new client component):**
Create following the research code example. An expandable banner at the top of the service detail page.

1. Props: `unavailableMembers: { memberId: string; memberName: string; reason: string | null }[]`
2. If empty array, render nothing
3. Render using shadcn/ui Collapsible:
   - Trigger: amber-styled banner bar with "{N} member(s) unavailable on this date" + ChevronDown
   - Content: list of member names with their reasons
4. Styling: amber border/background matching the scheduling warning aesthetic (amber-200 border, amber-50 bg, amber-800 text; dark mode variants)

**page.tsx — Integrate availability banner:**
In the service detail page server component:

1. Import getUnavailableMembersForService from lib/assignments/queries
2. After the existing parallel data fetches, call getUnavailableMembersForService(serviceId)
3. Render `<AvailabilityBanner unavailableMembers={unavailableMembers} />` between the service header and the service info grid (above the Cards, below the title/action buttons)
4. Import the AvailabilityBanner component
  </action>
  <verify>
    Run `pnpm build` to confirm all components compile. Run `pnpm lint` to check formatting. Navigate to a service detail page and verify: combobox shows unavailability icons, selecting unavailable member shows confirmation dialog, availability banner renders at top when members are unavailable.
  </verify>
  <done>
    Combobox shows CalendarOff icon next to unavailable members with tooltip showing reason. Selecting an unavailable member triggers "Member Unavailable -- Assign anyway?" dialog. Force-assigning proceeds normally. Service detail page shows amber availability banner with expandable member list at top. Unavailable members maintain their alphabetical sort position in the dropdown.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with zero TypeScript errors
2. `pnpm lint` passes with no Biome issues
3. getEligibleMembers returns isUnavailable and unavailabilityReason for each member
4. assignMember returns { unavailable } when member is unavailable and forceAssign is false
5. Combobox shows CalendarOff icon for unavailable members (same position, not reordered)
6. Selecting unavailable member shows "Assign anyway?" confirmation dialog
7. Confirming assignment creates the assignment successfully (forceAssign = true)
8. Service detail page shows availability banner with correct count and expandable list
9. Both conflict and unavailability warnings work independently and together
</verification>

<success_criteria>
- Availability data integrated into getEligibleMembers (batch query, not N+1)
- Combobox shows warning icon for unavailable members
- "Assign anyway?" dialog for unavailable members
- Availability banner on service detail page with expandable list
- All existing conflict detection continues to work unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-availability-management/05-03-SUMMARY.md`
</output>
