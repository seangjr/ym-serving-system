---
phase: 04-scheduling-and-assignments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00006_assignments.sql
  - lib/assignments/schemas.ts
  - lib/assignments/types.ts
  - lib/assignments/queries.ts
  - lib/assignments/actions.ts
autonomous: true

must_haves:
  truths:
    - "service_positions table stores per-service position slots (allowing multiples of the same position)"
    - "service_assignments table stores member-to-slot assignments with status state machine (pending/confirmed/declined)"
    - "schedule_templates table stores reusable position configurations as JSON"
    - "RLS policies allow authenticated users to read all three tables; mutations go through admin client"
    - "Server actions enforce admin/committee/team-lead authorization before mutating assignments"
    - "Conflict detection query finds overlapping service times for a member on the same date"
  artifacts:
    - path: "supabase/migrations/00006_assignments.sql"
      provides: "service_positions, service_assignments, schedule_templates tables with RLS and indexes"
      contains: "create table public.service_positions"
    - path: "lib/assignments/schemas.ts"
      provides: "Zod validation schemas for assignment inputs"
      contains: "assignMemberSchema"
    - path: "lib/assignments/types.ts"
      provides: "TypeScript interfaces for assignment data"
      contains: "ServiceAssignment"
    - path: "lib/assignments/queries.ts"
      provides: "Query functions for assignments, eligible members, conflicts, templates"
      exports: ["getServiceAssignments", "getEligibleMembers", "getMemberConflicts", "getTemplates"]
    - path: "lib/assignments/actions.ts"
      provides: "Server actions for assignment CRUD, position management, templates"
      exports: ["assignMember", "unassignMember", "addServicePosition", "removeServicePosition"]
  key_links:
    - from: "lib/assignments/actions.ts"
      to: "supabase/migrations/00006_assignments.sql"
      via: "Supabase admin client queries against new tables"
      pattern: "from\\(\"service_assignments\"\\)"
    - from: "lib/assignments/queries.ts"
      to: "supabase/migrations/00006_assignments.sql"
      via: "RLS-protected reads from new tables"
      pattern: "from\\(\"service_positions\"\\)"
    - from: "lib/assignments/actions.ts"
      to: "lib/assignments/schemas.ts"
      via: "Zod validation before mutations"
      pattern: "safeParse"
---

<objective>
Create the database schema and complete server-side module for scheduling and assignments.

Purpose: Establish the data foundation (3 new tables) and full server-side API (schemas, queries, actions) that the assignment UI (Plan 02) and template UI (Plan 03) will consume. This is the foundational layer -- no UI in this plan.

Output: SQL migration applied, `lib/assignments/` module with schemas, types, queries, and server actions ready for client consumption.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-scheduling-and-assignments/04-CONTEXT.md
@.planning/phases/04-scheduling-and-assignments/04-RESEARCH.md

@supabase/migrations/00003_serving_teams.sql
@supabase/migrations/00005_services.sql
@lib/services/actions.ts
@lib/services/schemas.ts
@lib/services/queries.ts
@lib/teams/queries.ts
@lib/auth/roles.ts
@lib/supabase/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create assignment database migration</name>
  <files>supabase/migrations/00006_assignments.sql</files>
  <action>
Create SQL migration `00006_assignments.sql` with three tables:

**1. `service_positions`** -- per-service position slots (NOT same as team_positions):
- `id` uuid PK default gen_random_uuid()
- `service_id` uuid NOT NULL FK -> services(id) ON DELETE CASCADE
- `team_id` uuid NOT NULL FK -> serving_teams(id) ON DELETE CASCADE
- `position_id` uuid NOT NULL FK -> team_positions(id) ON DELETE CASCADE
- `sort_order` int NOT NULL DEFAULT 0
- `created_at` timestamptz NOT NULL DEFAULT now()
- NO unique constraint on (service_id, position_id) -- multiples of the same position allowed per user decision (e.g., 2 Vocalists)
- Add composite index on (service_id, team_id) for assignment grid queries

**2. `service_assignments`** -- member assigned to a position slot:
- `id` uuid PK default gen_random_uuid()
- `service_position_id` uuid NOT NULL FK -> service_positions(id) ON DELETE CASCADE
- `member_id` uuid NOT NULL FK -> members(id) ON DELETE CASCADE
- `status` text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'declined'))
- `notes` text -- per-assignment notes (per user decision ASGN-04)
- `has_conflict` boolean NOT NULL DEFAULT false -- persistent warning badge flag
- `assigned_by` uuid FK -> members(id) ON DELETE SET NULL
- `assigned_at` timestamptz NOT NULL DEFAULT now()
- `updated_at` timestamptz NOT NULL DEFAULT now()
- UNIQUE(service_position_id) -- one member per slot; add another service_position for duplicate positions
- Add index on (member_id) for conflict detection queries

**3. `schedule_templates`** -- reusable position configurations:
- `id` uuid PK default gen_random_uuid()
- `name` text NOT NULL
- `description` text
- `team_id` uuid FK -> serving_teams(id) ON DELETE SET NULL
- `positions` jsonb NOT NULL DEFAULT '[]' -- array of { position_id, position_name, category, count }
- `created_by` uuid FK -> members(id) ON DELETE SET NULL
- `created_at` timestamptz NOT NULL DEFAULT now()
- `updated_at` timestamptz NOT NULL DEFAULT now()

**RLS policies** (same pattern as 00003 and 00005):
- All three tables: Enable RLS, add SELECT policy for `authenticated` with `using (true)`
- Mutations go through server actions using createAdminClient() (bypasses RLS)

**Triggers:**
- `updated_at` trigger on `service_assignments` using existing `update_updated_at_column()` function
- `updated_at` trigger on `schedule_templates` using existing `update_updated_at_column()` function

Follow the exact SQL style of `00005_services.sql` -- section comments, consistent formatting, table creation order respecting FK dependencies.
  </action>
  <verify>
Run `supabase db push` (or verify migration applies) without errors. Check that all three tables, RLS policies, indexes, and triggers are created.
  </verify>
  <done>
Three tables (service_positions, service_assignments, schedule_templates) exist with correct columns, constraints, RLS policies (SELECT for authenticated), indexes, and updated_at triggers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lib/assignments module (schemas, types, queries, actions)</name>
  <files>
lib/assignments/schemas.ts
lib/assignments/types.ts
lib/assignments/queries.ts
lib/assignments/actions.ts
  </files>
  <action>
Create the complete `lib/assignments/` module following the established patterns from `lib/services/` and `lib/teams/`.

**schemas.ts** -- Zod validation schemas:
- `assignMemberSchema`: { servicePositionId: uuid, memberId: uuid, serviceId: uuid, notes?: string (max 500), forceAssign?: boolean }
- `unassignMemberSchema`: { servicePositionId: uuid, serviceId: uuid }
- `addServicePositionSchema`: { serviceId: uuid, teamId: uuid, positionId: uuid }
- `removeServicePositionSchema`: { servicePositionId: uuid, serviceId: uuid }
- `updateAssignmentNoteSchema`: { assignmentId: uuid, serviceId: uuid, notes: string (max 500, allow empty for clearing) }
- `saveTemplateSchema`: { name: string (1-100), description?: string (max 500), teamId: uuid, serviceId: uuid }
- `loadTemplateSchema`: { templateId: uuid, serviceId: uuid }
- `deleteTemplateSchema`: { templateId: uuid }
- Export inferred types for all schemas
- Use the established pattern: `z.union([z.string().uuid(), z.literal("")]).optional()` for optional UUID fields
- Use the empty string pattern from MEMORY.md for optional text fields

**types.ts** -- TypeScript interfaces:
- `ServicePositionWithAssignment`: { id, serviceId, teamId, positionId, positionName, category, sortOrder, assignment: { id, memberId, memberName, status, notes, hasConflict, assignedAt } | null }
- `TeamAssignmentGroup`: { teamId, teamName, teamColor, categories: Record<string, ServicePositionWithAssignment[]> }
- `EligibleMember`: { id, fullName, hasConflict, conflictDetails: { serviceName, serviceTime, positionName } | null }
- `ConflictInfo`: { assignmentId, serviceName, serviceTime, positionName }
- `TemplateListItem`: { id, name, description, teamId, teamName, positionCount, createdAt }
- `TemplateDetail`: { id, name, description, teamId, positions: { positionId, positionName, category, count }[] }

**queries.ts** -- Query functions using RLS-protected client (pattern from `lib/services/queries.ts`):
- `getServiceAssignments(serviceId)`: Fetch all service_positions for a service with their assignments, joined with team_positions (name, category), serving_teams (name, color), members (full_name). Return grouped by team then by category. This is the main data fetch for the assignment panel.
- `getEligibleMembers(teamId, serviceId)`: Fetch team_members for the given team (via team_members table). For each member, check if they have a conflicting assignment on the same service_date with overlapping times. Return EligibleMember[] with conflict info pre-computed. Use a SINGLE query that fetches all same-date assignments for team members, then compute conflicts in application code (avoid N+1 per Pitfall 1 from RESEARCH.md).
- `getMemberConflicts(memberId, serviceId)`: Detailed conflict check for a specific member against a specific service. Used before assignment to get full conflict details for the confirmation dialog. Query services where member is assigned (via service_assignments -> service_positions -> services), filter to same date and overlapping times. Handle null end_time by calculating from start_time + duration_minutes (default 120 per RESEARCH Pitfall 4).
- `getTemplates(teamId?)`: List templates, optionally filtered by team. Return TemplateListItem[].
- `getTemplateById(templateId)`: Full template detail for loading.

**actions.ts** -- Server actions following `lib/services/actions.ts` pattern:
- `assignMember(data)`: Validate with assignMemberSchema. Auth check: admin/committee always allowed; team lead check via team_members table for the team. If forceAssign is false and conflicts exist, return `{ conflict: ConflictInfo }`. If forceAssign is true, insert assignment with `has_conflict: true`. Otherwise insert with `has_conflict: false`. Status always 'pending' (accept/decline is Phase 6). revalidatePath(`/services/${serviceId}`).
- `unassignMember(data)`: Delete service_assignment by service_position_id. Auth check same as assign. revalidatePath.
- `addServicePosition(data)`: Insert into service_positions. Auto-compute sort_order (max existing + 1 for the service). Auth check. revalidatePath.
- `removeServicePosition(data)`: Delete from service_positions (CASCADE will delete assignment). Auth check. revalidatePath.
- `updateAssignmentNote(data)`: Update notes field on service_assignments. Auth check. revalidatePath.
- `saveTemplate(data)`: Query service_positions for the service and team, build positions JSON snapshot, insert into schedule_templates. Auth check (admin/committee). revalidatePath.
- `loadTemplate(data)`: Read template, insert service_positions for each template position entry. If positions already exist for that team on the service, delete them first (replace). Auth check. revalidatePath.
- `deleteTemplate(data)`: Delete from schedule_templates. Auth check (admin/committee). revalidatePath.

For conflict detection in `assignMember`: Call `getMemberConflicts()` from queries.ts. If conflicts found and `forceAssign` is false, return the conflict info. If `forceAssign` is true, proceed with insert and set `has_conflict: true`.

Return type pattern: `Promise<{ success: true } | { error: string } | { conflict: ConflictInfo }>` for assignMember; standard `Promise<{ success: true } | { error: string }>` for all others.

Use `createAdminClient()` for all mutations, `createClient()` for auth checks. Follow the exact error handling pattern from `lib/services/actions.ts` (safeParse, error.issues[0]?.message).
  </action>
  <verify>
Run `pnpm build` to confirm TypeScript compilation. Verify all exports are accessible. Check that the module follows the same patterns as lib/services/ and lib/teams/.
  </verify>
  <done>
lib/assignments/ module exists with schemas.ts (8 schemas), types.ts (6 interfaces), queries.ts (5 query functions), and actions.ts (8 server actions). All follow established patterns. Conflict detection handles null end_time. Authorization checks are consistent with existing codebase.
  </done>
</task>

</tasks>

<verification>
1. `supabase db push` applies migration without errors
2. `pnpm build` succeeds with no TypeScript errors
3. All three tables visible in Supabase dashboard
4. RLS policies allow authenticated SELECT on all three tables
5. lib/assignments/ module exports match the specified interfaces
</verification>

<success_criteria>
- Database migration creates service_positions, service_assignments, schedule_templates with correct schema
- lib/assignments/ module provides complete server-side API for assignment CRUD, conflict detection, and templates
- No new dependencies required (all libraries already installed)
- Patterns match existing lib/services/ and lib/teams/ modules exactly
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduling-and-assignments/04-01-SUMMARY.md`
</output>
