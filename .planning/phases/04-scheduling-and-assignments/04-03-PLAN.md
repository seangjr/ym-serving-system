---
phase: 04-scheduling-and-assignments
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - app/(app)/services/[serviceId]/template-dialog.tsx
  - app/(app)/services/[serviceId]/service-detail-actions.tsx
  - app/(app)/services/[serviceId]/page.tsx
  - lib/services/queries.ts
  - app/(app)/dashboard/page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin/committee can save a service's position configuration as a named template"
    - "Admin/committee can load a saved template onto a service, replacing existing positions for that team"
    - "Templates are scoped to a specific team and show position count and creation date"
    - "Dashboard stats show real unassigned positions count (not hardcoded 0)"
    - "Dashboard stats show real pending confirmations count (not hardcoded 0)"
  artifacts:
    - path: "app/(app)/services/[serviceId]/template-dialog.tsx"
      provides: "Save and load template dialogs"
      contains: "SaveTemplateDialog"
    - path: "app/(app)/services/[serviceId]/service-detail-actions.tsx"
      provides: "Updated action bar with template buttons"
      contains: "Save as Template"
    - path: "lib/services/queries.ts"
      provides: "Updated getServiceStats with real assignment counts"
      contains: "service_assignments"
  key_links:
    - from: "app/(app)/services/[serviceId]/template-dialog.tsx"
      to: "lib/assignments/actions.ts"
      via: "Server action calls for saveTemplate, loadTemplate, deleteTemplate"
      pattern: "saveTemplate|loadTemplate"
    - from: "lib/services/queries.ts"
      to: "supabase/migrations/00006_assignments.sql"
      via: "Queries against service_positions and service_assignments for dashboard stats"
      pattern: "service_assignments|service_positions"
---

<objective>
Add the template save/load workflow and update dashboard stats to use real assignment data.

Purpose: Templates provide "quick setup" for recurring service configurations (e.g., a standard Sunday morning team). Dashboard stats give team leads visibility into scheduling gaps. Both complete the Phase 4 feature set.

Output: Template save/load UI integrated into service detail page, dashboard stats showing real assignment data.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-scheduling-and-assignments/04-CONTEXT.md
@.planning/phases/04-scheduling-and-assignments/04-RESEARCH.md
@.planning/phases/04-scheduling-and-assignments/04-01-SUMMARY.md
@.planning/phases/04-scheduling-and-assignments/04-02-SUMMARY.md

@app/(app)/services/[serviceId]/page.tsx
@app/(app)/services/[serviceId]/service-detail-actions.tsx
@app/(app)/services/[serviceId]/assignment-panel.tsx
@lib/assignments/actions.ts
@lib/assignments/queries.ts
@lib/assignments/types.ts
@lib/services/queries.ts
@app/(app)/dashboard/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build template save/load dialogs and integrate into service detail page</name>
  <files>
app/(app)/services/[serviceId]/template-dialog.tsx
app/(app)/services/[serviceId]/service-detail-actions.tsx
app/(app)/services/[serviceId]/page.tsx
  </files>
  <action>
**Create `template-dialog.tsx`** ("use client"):

Two dialog components in one file:

**SaveTemplateDialog:**
- Props: `open: boolean`, `onOpenChange`, `serviceId: string`, `teams: { id, name }[]`
- Dialog content:
  - Title: "Save as Template"
  - Form fields: template name (required, text input), description (optional, textarea), team selector (Select dropdown -- which team's positions to save)
  - Uses react-hook-form with Zod resolver (saveTemplateSchema from lib/assignments/schemas)
  - On submit, calls `saveTemplate` server action
  - Success: toast "Template saved", close dialog
  - Error: toast.error with message
- Use Dialog (not AlertDialog) since this is a form, not a confirmation

**LoadTemplateDialog:**
- Props: `open: boolean`, `onOpenChange`, `serviceId: string`, `teams: { id, name }[]`
- Dialog content:
  - Title: "Load Template"
  - Shows a scrollable list of templates, filtered by a team selector at the top
  - Each template item shows: name, description (if any), position count, creation date
  - Templates fetched via a query function or passed as prop from page.tsx
  - Clicking a template item selects it
  - A "Load" button at the bottom applies the selected template
  - If the service already has positions for the selected team, show a warning: "This will replace existing positions for {team name}."
  - On load, calls `loadTemplate` server action
  - Success: toast "Template loaded ({N} positions added)", close dialog
  - Error: toast.error with message
  - Also include a small delete button (trash icon) on each template for cleanup
- Templates are sorted by most recently created (per Claude's discretion)

**Update `service-detail-actions.tsx`:**
- Add two new buttons to the action bar (only when canManage):
  - "Save as Template" button (Save icon) -- opens SaveTemplateDialog
  - "Load Template" button (Upload icon) -- opens LoadTemplateDialog
- Import and render both dialog components
- Pass necessary props (serviceId, teams data)
- The buttons should appear alongside the existing Edit/Duplicate/Delete buttons

**Update `page.tsx`:**
- Fetch templates data to pass to the dialogs (use getTemplates from lib/assignments/queries.ts)
- Pass teams list (teams that have positions) to service-detail-actions for template dialogs
- If not already done in Plan 02, ensure the page fetches the list of all active teams with their positions for both the PositionAdder and template dialogs
  </action>
  <verify>
Run `pnpm build` to confirm no TypeScript errors. In the browser:
1. Open a service detail page with some positions added
2. Click "Save as Template" -- dialog opens with form
3. Fill in name and select team, submit -- template saves
4. Click "Load Template" -- dialog opens, shows saved template
5. Select and load template -- positions appear on the service
  </verify>
  <done>
Admin/committee can save service position configurations as named templates scoped to a team, browse/load templates onto services, and delete templates. Template loading replaces existing positions for the selected team.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update dashboard stats with real assignment data</name>
  <files>
lib/services/queries.ts
app/(app)/dashboard/page.tsx
  </files>
  <action>
**Update `lib/services/queries.ts` `getServiceStats()`:**
- Replace the hardcoded `unassignedPositions: 0` and `pendingConfirmations: 0` with real queries.
- **Unassigned positions count:** Count service_positions for upcoming (non-cancelled) services that do NOT have a corresponding service_assignments row. Use a left join or subquery:
  ```
  SELECT count(sp.id)
  FROM service_positions sp
  JOIN services s ON sp.service_id = s.id
  LEFT JOIN service_assignments sa ON sa.service_position_id = sp.id
  WHERE s.service_date >= today
    AND s.is_cancelled = false
    AND sa.id IS NULL
  ```
  Implement via Supabase query builder. Since this is a complex join with NULL check, use `.rpc()` with a Postgres function OR do it in two queries: (1) count all service_positions for upcoming services, (2) count all service_assignments for upcoming services, subtract.

  Simpler approach: Two count queries:
  1. Count total service_positions for upcoming, non-cancelled services
  2. Count total service_assignments for upcoming, non-cancelled services (via join through service_positions)
  3. unassignedPositions = total positions - total assignments

- **Pending confirmations count:** Count service_assignments with `status = 'pending'` for upcoming, non-cancelled services:
  ```
  SELECT count(sa.id)
  FROM service_assignments sa
  JOIN service_positions sp ON sa.service_position_id = sp.id
  JOIN services s ON sp.service_id = s.id
  WHERE s.service_date >= today
    AND s.is_cancelled = false
    AND sa.status = 'pending'
  ```
  This can be done with Supabase query builder by joining through service_positions to services.

Since Supabase PostgREST has limited support for complex aggregations across joins, the most reliable approach is:
1. Fetch upcoming non-cancelled service IDs first
2. Count service_positions for those service IDs
3. Count service_assignments for those service IDs
4. Count pending service_assignments for those service IDs

OR create a small Postgres function in the migration and call via `.rpc()`. Choose whichever is cleaner.

If using application-level aggregation: fetch service_positions with count for upcoming services, and service_assignments with count for upcoming services. The overhead is minimal (just counts, no row data).

**Update `app/(app)/dashboard/page.tsx`:**
- The dashboard already renders ServiceStats with `unassignedPositions` and `pendingConfirmations` values from `getServiceStats()`. Once the query is updated, the dashboard should display real numbers automatically.
- Verify that the stats cards render the new values correctly.
- If the stats card labels say anything about Phase 4 placeholder, update the text to show the real information.

Also check `components/services/service-stats.tsx` (or wherever the stats are rendered) to ensure labels are appropriate:
- "Unassigned Positions" -- shows the count of position slots without members
- "Pending Confirmations" -- shows the count of assignments awaiting response
  </action>
  <verify>
Run `pnpm build` to confirm no TypeScript errors. In the browser:
1. Navigate to dashboard
2. Stats cards show actual numbers (not hardcoded 0)
3. After assigning a member to a position, the "Unassigned Positions" count decreases
4. New assignments show in "Pending Confirmations" count
  </verify>
  <done>
Dashboard stats display real-time unassigned position counts and pending confirmation counts from the service_assignments and service_positions tables. No more hardcoded placeholder values.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds with no TypeScript errors
2. Template save dialog creates templates with name, description, and team scope
3. Template load dialog lists templates filtered by team, applies positions to service
4. Template delete removes the template
5. Dashboard "Unassigned Positions" shows real count from service_positions without assignments
6. Dashboard "Pending Confirmations" shows real count from service_assignments with status='pending'
7. Both stats update correctly after assignment operations
</verification>

<success_criteria>
- Templates workflow complete: save, browse/load, delete (ASGN-08, ASGN-09)
- Dashboard stats no longer hardcoded to 0 (SERV-04 completion)
- All operations use established patterns (server actions, admin client, revalidatePath, toast notifications)
- Template data persists across page refreshes (stored in schedule_templates table)
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduling-and-assignments/04-03-SUMMARY.md`
</output>
