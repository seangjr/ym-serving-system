---
phase: 01-foundation-and-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/supabase/client.ts
  - lib/supabase/server.ts
  - lib/supabase/middleware.ts
  - middleware.ts
  - app/auth/callback/route.ts
  - app/auth/confirm/route.ts
  - app/auth/signout/route.ts
  - .env.local.example
autonomous: true
user_setup:
  - service: supabase
    why: "Authentication and database backend -- existing project shared with attendance system"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon public key"
      - name: NEXT_PUBLIC_SITE_URL
        source: "http://localhost:3000 for dev, production URL for deploy"
    dashboard_config:
      - task: "Enable Email/Password auth provider"
        location: "Supabase Dashboard -> Authentication -> Providers -> Email"
      - task: "Add site URL to redirect allowlist"
        location: "Supabase Dashboard -> Authentication -> URL Configuration"
      - task: "Set redirect URLs: http://localhost:3000/auth/callback, http://localhost:3000/auth/confirm"
        location: "Supabase Dashboard -> Authentication -> URL Configuration -> Redirect URLs"

must_haves:
  truths:
    - "Supabase browser client can be created in any client component"
    - "Supabase server client can be created in any server component or server action"
    - "Middleware refreshes auth tokens on every request automatically"
    - "Unauthenticated users hitting any non-auth route are redirected to /login"
    - "Password reset email link lands on /auth/callback and exchanges code for session"
    - "Sign out clears session and redirects to /login"
  artifacts:
    - path: "lib/supabase/client.ts"
      provides: "Browser Supabase client factory"
      exports: ["createClient"]
    - path: "lib/supabase/server.ts"
      provides: "Server Supabase client factory with cookie handling"
      exports: ["createClient"]
    - path: "lib/supabase/middleware.ts"
      provides: "Session refresh logic for middleware"
      exports: ["updateSession"]
    - path: "middleware.ts"
      provides: "Next.js middleware entry point"
      exports: ["middleware", "config"]
    - path: "app/auth/callback/route.ts"
      provides: "PKCE code exchange route handler"
      exports: ["GET"]
    - path: "app/auth/confirm/route.ts"
      provides: "Email OTP verification route handler"
      exports: ["GET"]
    - path: "app/auth/signout/route.ts"
      provides: "Sign-out route handler"
      exports: ["POST"]
  key_links:
    - from: "middleware.ts"
      to: "lib/supabase/middleware.ts"
      via: "imports updateSession"
      pattern: "import.*updateSession.*from.*@/lib/supabase/middleware"
    - from: "lib/supabase/middleware.ts"
      to: "@supabase/ssr"
      via: "createServerClient for cookie-based auth"
      pattern: "createServerClient"
    - from: "app/auth/callback/route.ts"
      to: "lib/supabase/server.ts"
      via: "uses server client to exchange code"
      pattern: "exchangeCodeForSession"
---

<objective>
Set up Supabase client infrastructure for Next.js 16 App Router with cookie-based auth session management, middleware-based token refresh, and PKCE auth callback route handlers.

Purpose: This is the foundational plumbing that every auth flow (login, logout, password reset) and every protected route depends on. Without middleware refreshing tokens on every request, server components would silently fail with stale sessions.

Output: Browser client factory, server client factory, middleware with session refresh and auth redirect, PKCE callback handlers, sign-out route handler, and env var template.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Supabase packages and create client factories</name>
  <files>
    lib/supabase/client.ts
    lib/supabase/server.ts
    .env.local.example
  </files>
  <action>
    1. Install Supabase packages: `pnpm add @supabase/supabase-js @supabase/ssr`

    2. Create `.env.local.example` with these variables (no values, just keys):
       ```
       NEXT_PUBLIC_SUPABASE_URL=
       NEXT_PUBLIC_SUPABASE_ANON_KEY=
       NEXT_PUBLIC_SITE_URL=http://localhost:3000
       ```
       Note: Use `NEXT_PUBLIC_SUPABASE_ANON_KEY` (not PUBLISHABLE_KEY) per research recommendation for compatibility.

    3. Create `lib/supabase/client.ts` -- browser client factory:
       - Import `createBrowserClient` from `@supabase/ssr`
       - Export a `createClient()` function that returns `createBrowserClient(NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY)`
       - Use non-null assertions on env vars (they're required)

    4. Create `lib/supabase/server.ts` -- server client factory:
       - Import `createServerClient` from `@supabase/ssr`
       - Import `cookies` from `next/headers`
       - Export an async `createClient()` function
       - Get cookie store via `await cookies()`
       - Pass `getAll()` and `setAll()` cookie methods (NOT individual get/set/remove)
       - Wrap `setAll` in try/catch -- Server Components can't set cookies, middleware handles it
       - This is the exact pattern from the research doc -- do not deviate

    Run `pnpm format` after creating files.
  </action>
  <verify>
    - `pnpm build` succeeds (TypeScript compiles)
    - `lib/supabase/client.ts` exists and exports `createClient`
    - `lib/supabase/server.ts` exists and exports async `createClient`
    - `.env.local.example` exists with all 3 env vars
  </verify>
  <done>
    Browser and server Supabase client factories exist, use `@supabase/ssr` with correct `getAll`/`setAll` cookie pattern, and TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create middleware and auth route handlers</name>
  <files>
    lib/supabase/middleware.ts
    middleware.ts
    app/auth/callback/route.ts
    app/auth/confirm/route.ts
    app/auth/signout/route.ts
  </files>
  <action>
    1. Create `lib/supabase/middleware.ts` -- session refresh logic:
       - Import `createServerClient` from `@supabase/ssr`
       - Import `NextResponse`, `NextRequest` from `next/server`
       - Export `updateSession(request: NextRequest)` function
       - Create a server client with request cookies for `getAll` and response cookies for `setAll`
       - Call `supabase.auth.getUser()` (NOT `getSession()` -- security requirement from research)
       - If no user AND path is not `/login`, `/auth/*`, `/reset-password`, or `/update-password`:
         redirect to `/login`
       - If user exists AND path is `/login` or `/reset-password`:
         redirect to `/` (don't show login to authenticated users)
       - Return the supabaseResponse with updated cookies

    2. Create `middleware.ts` (project root):
       - Import `updateSession` from `@/lib/supabase/middleware`
       - Export async `middleware(request)` that calls `updateSession`
       - Export `config.matcher` that excludes static files:
         `'/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'`

    3. Create `app/auth/callback/route.ts` -- PKCE code exchange:
       - Handle GET requests
       - Extract `code` and `next` from URL search params
       - If code exists, create server client and call `exchangeCodeForSession(code)`
       - On success: redirect to `next` param (default `/`)
       - On error: redirect to `/login?error=auth-code-error`
       - Handle `x-forwarded-host` for production deployments

    4. Create `app/auth/confirm/route.ts` -- email OTP verification:
       - Handle GET requests
       - Extract `token_hash` and `type` from search params
       - If both exist, call `supabase.auth.verifyOtp({ type, token_hash })`
       - On success: redirect to `/`
       - On error: redirect to `/login?error=verification-failed`

    5. Create `app/auth/signout/route.ts` -- sign out:
       - Handle POST requests
       - Create server client, check for user via `getUser()`
       - If user exists, call `supabase.auth.signOut()`
       - Call `revalidatePath('/', 'layout')` to clear cached pages
       - Redirect to `/login` with 302

    Run `pnpm format` after creating files.
  </action>
  <verify>
    - `pnpm build` succeeds
    - `middleware.ts` exists at project root and imports from `@/lib/supabase/middleware`
    - All 3 route handlers exist under `app/auth/`
    - Middleware matcher excludes static files
    - No usage of deprecated `getSession()` -- only `getUser()` used in server contexts
  </verify>
  <done>
    Middleware intercepts all non-static requests, refreshes auth tokens, redirects unauthenticated users to /login. PKCE callback exchanges auth codes for sessions. Sign-out clears session and redirects. All route handlers use server client with proper cookie handling.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with zero TypeScript errors
2. All 7 files exist at their specified paths
3. No usage of deprecated `@supabase/auth-helpers-nextjs` or `getSession()` in server code
4. Middleware matcher pattern excludes static assets
5. Server client uses `getAll`/`setAll` (not individual `get`/`set`/`remove`)
6. `.env.local.example` documents all required env vars
</verification>

<success_criteria>
- Supabase client infrastructure is fully set up for both browser and server contexts
- Middleware refreshes auth tokens on every request and redirects unauthenticated users
- PKCE callback route handles password reset email links correctly
- Sign-out route handler clears session and redirects
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-01-SUMMARY.md`
</output>
