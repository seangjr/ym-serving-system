---
phase: 01-foundation-and-authentication
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - supabase/migrations/00001_roles_and_rls.sql
  - lib/auth/roles.ts
autonomous: true
user_setup:
  - service: supabase
    why: "SQL migration must be run in Supabase SQL editor or via CLI"
    dashboard_config:
      - task: "Run the SQL migration file (supabase/migrations/00001_roles_and_rls.sql) in the Supabase SQL Editor"
        location: "Supabase Dashboard -> SQL Editor -> New query -> paste and run"
      - task: "Enable the custom access token hook"
        location: "Supabase Dashboard -> Authentication -> Hooks -> Enable 'Custom access token' hook -> select public.custom_access_token_hook"
      - task: "Verify hook is active by checking a user's JWT claims include 'user_role'"
        location: "Supabase Dashboard -> Authentication -> Users -> select a user -> inspect JWT"

must_haves:
  truths:
    - "SQL migration creates app_role enum with admin, committee, member values"
    - "SQL migration creates user_roles table linking auth.users to roles"
    - "Custom access token hook embeds user_role in JWT claims"
    - "has_role() SQL function checks role from JWT without DB query"
    - "has_role_or_higher() SQL function implements role hierarchy (admin > committee > member)"
    - "RLS policies on user_roles restrict role management to admins"
    - "TypeScript role types match the SQL enum exactly"
    - "getUserRole helper extracts role from Supabase session JWT"
  artifacts:
    - path: "supabase/migrations/00001_roles_and_rls.sql"
      provides: "Database schema for roles, custom access token hook, RLS policies"
      contains: "app_role"
    - path: "lib/auth/roles.ts"
      provides: "TypeScript role types and helper functions"
      exports: ["AppRole", "ROLES", "getUserRole", "hasRoleOrHigher", "isAdmin", "isCommittee"]
  key_links:
    - from: "supabase/migrations/00001_roles_and_rls.sql"
      to: "auth.users"
      via: "user_roles.user_id references auth.users"
      pattern: "references auth.users"
    - from: "lib/auth/roles.ts"
      to: "supabase/migrations/00001_roles_and_rls.sql"
      via: "TypeScript types mirror SQL enum values"
      pattern: "admin.*committee.*member"
---

<objective>
Create the role management infrastructure: SQL migration for user_roles table with custom access token hook embedding roles in JWTs, RLS policies restricting role management to admins, and TypeScript helpers for role checking.

Purpose: Role-based access control is the backbone of the app. The sidebar shows different navigation items, RLS policies restrict database access, and UI elements hide/show based on user role. All of this depends on roles being embedded in the JWT via the custom access token hook.

Output: SQL migration file, TypeScript role types and helpers.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-and-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL migration for roles, access token hook, and RLS policies</name>
  <files>
    supabase/migrations/00001_roles_and_rls.sql
  </files>
  <action>
    Create `supabase/migrations/00001_roles_and_rls.sql` with the following SQL sections. Use clear section comments for readability.

    **Section 1: Role enum and user_roles table**
    ```sql
    -- Role enum: admin > committee > member (hierarchy)
    -- "committee" replaces "team lead" per user decision
    create type public.app_role as enum ('admin', 'committee', 'member');

    create table public.user_roles (
      id bigint generated by default as identity primary key,
      user_id uuid references auth.users on delete cascade not null,
      role app_role not null default 'member',
      created_at timestamptz default now() not null,
      updated_at timestamptz default now() not null,
      unique (user_id, role)
    );

    -- Enable RLS
    alter table public.user_roles enable row level security;
    ```

    **Section 2: Custom access token hook**
    Create `custom_access_token_hook(event jsonb)` exactly as specified in the research doc:
    - Query user_roles for the user's role
    - Embed `user_role` claim in JWT
    - Default to `'member'` if no role found
    - Mark function as `stable` for performance

    **Section 3: Grant permissions to supabase_auth_admin**
    - Grant usage on public schema
    - Grant execute on the hook function
    - Revoke execute from authenticated, anon, public
    - Grant all on user_roles table to supabase_auth_admin
    - Revoke all from authenticated, anon, public on user_roles
    - Add select policy for auth admin on user_roles

    **Section 4: Role check helper functions**
    - `has_role(required_role app_role)`: checks if JWT `user_role` matches exactly
    - `has_role_or_higher(required_role app_role)`: checks role hierarchy (admin >= committee >= member)
    - Both functions: `language plpgsql stable security definer set search_path = ''`

    **Section 5: RLS policies on user_roles**
    - "Admins can manage all roles": admin can SELECT, INSERT, UPDATE, DELETE on user_roles
    - "Users can read own role": any authenticated user can SELECT where user_id matches auth.uid()
    - "Auth admin can read roles": supabase_auth_admin can SELECT (for the hook)

    **Section 6: Updated_at trigger**
    Create a trigger function and trigger on user_roles that auto-updates `updated_at` on row changes.

    Note: This SQL file is meant to be run manually in the Supabase SQL Editor or via Supabase CLI. It is NOT auto-migrated. Include a comment at the top explaining this.
  </action>
  <verify>
    - File exists at `supabase/migrations/00001_roles_and_rls.sql`
    - SQL is syntactically valid (no obvious syntax errors)
    - Contains: `app_role` enum, `user_roles` table, `custom_access_token_hook`, `has_role`, `has_role_or_higher`
    - RLS is enabled on user_roles
    - All grant/revoke statements present for auth admin
  </verify>
  <done>
    SQL migration file creates the complete RBAC infrastructure: role enum (admin, committee, member), user_roles table with RLS, custom access token hook that embeds role in JWT, helper functions for RLS policy checks, and appropriate permission grants.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript role types and helper functions</name>
  <files>
    lib/auth/roles.ts
  </files>
  <action>
    Create `lib/auth/roles.ts` with:

    1. **Type definitions:**
       ```typescript
       export type AppRole = 'admin' | 'committee' | 'member'
       ```
       This MUST match the SQL enum exactly.

    2. **Role constants:**
       ```typescript
       export const ROLES = {
         ADMIN: 'admin' as const,
         COMMITTEE: 'committee' as const,
         MEMBER: 'member' as const,
       }

       // Role hierarchy: higher index = higher privilege
       const ROLE_HIERARCHY: AppRole[] = ['member', 'committee', 'admin']
       ```

    3. **Role extraction from session:**
       ```typescript
       import type { Session } from '@supabase/supabase-js'

       interface JwtWithRole {
         user_role?: AppRole
       }

       export function getUserRole(session: Session | null): AppRole {
         if (!session) return 'member'
         // Role is embedded in JWT by custom access token hook
         const claims = session.access_token
           ? JSON.parse(atob(session.access_token.split('.')[1])) as JwtWithRole
           : null
         return claims?.user_role ?? 'member'
       }
       ```
       Note: Use manual JWT decode (split + atob) to avoid adding jwt-decode dependency. The JWT is already verified by Supabase -- we're just reading claims.

    4. **Role comparison helpers:**
       ```typescript
       export function hasRoleOrHigher(userRole: AppRole, requiredRole: AppRole): boolean {
         return ROLE_HIERARCHY.indexOf(userRole) >= ROLE_HIERARCHY.indexOf(requiredRole)
       }

       export function isAdmin(role: AppRole): boolean {
         return role === 'admin'
       }

       export function isCommittee(role: AppRole): boolean {
         return role === 'committee'
       }

       export function isAdminOrCommittee(role: AppRole): boolean {
         return role === 'admin' || role === 'committee'
       }
       ```

    5. **Navigation items per role (for sidebar):**
       ```typescript
       export interface NavItem {
         title: string
         href: string
         icon: string  // Lucide icon name
       }

       export const ADMIN_NAV_ITEMS: NavItem[] = [
         { title: 'Services', href: '/dashboard', icon: 'Calendar' },
         { title: 'Team Roster', href: '/team-roster', icon: 'Users' },
         { title: 'Songs', href: '/songs', icon: 'Music' },
         { title: 'Announcements', href: '/announcements', icon: 'Megaphone' },
         { title: 'Equipment', href: '/equipment', icon: 'Wrench' },
         { title: 'Reports', href: '/reports', icon: 'BarChart3' },
         { title: 'Files', href: '/files', icon: 'FolderOpen' },
       ]

       export const MEMBER_NAV_ITEMS: NavItem[] = [
         { title: 'My Schedule', href: '/my-schedule', icon: 'CalendarCheck' },
         { title: 'Songs', href: '/songs', icon: 'Music' },
         { title: 'Announcements', href: '/announcements', icon: 'Megaphone' },
         { title: 'Files', href: '/files', icon: 'FolderOpen' },
       ]

       export function getNavItems(role: AppRole): NavItem[] {
         return role === 'member' ? MEMBER_NAV_ITEMS : ADMIN_NAV_ITEMS
       }

       export function getDefaultRoute(role: AppRole): string {
         return role === 'member' ? '/my-schedule' : '/dashboard'
       }
       ```

    Run `pnpm format` after creating the file.
  </action>
  <verify>
    - `pnpm build` succeeds
    - `lib/auth/roles.ts` exports: `AppRole`, `ROLES`, `getUserRole`, `hasRoleOrHigher`, `isAdmin`, `isCommittee`, `isAdminOrCommittee`, `getNavItems`, `getDefaultRoute`
    - Role type matches SQL enum: 'admin', 'committee', 'member'
    - `getUserRole` handles null session gracefully (returns 'member')
    - `ADMIN_NAV_ITEMS` has 7 items per user decision (Services, Team Roster, Songs, Announcements, Equipment, Reports, Files)
    - `MEMBER_NAV_ITEMS` has 4 items per user decision (My Schedule, Songs, Announcements, Files)
  </verify>
  <done>
    TypeScript role infrastructure exports role types matching SQL enum, JWT role extraction from session, role hierarchy comparison helpers, and role-filtered navigation items for the sidebar. Admin/Committee see 7 nav items, Members see 4.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes
2. SQL migration file is well-structured with clear section comments
3. TypeScript `AppRole` type matches SQL `app_role` enum exactly
4. Navigation items match user decision: Admin/Committee get 7 items, Members get 4
5. Role names use "committee" (not "team lead") per user decision
6. `getUserRole` safely handles null/missing session
7. No external JWT decode dependency needed
</verification>

<success_criteria>
- SQL migration is ready to run in Supabase SQL Editor (complete, self-contained)
- Custom access token hook will embed `user_role` claim in JWTs after activation
- TypeScript role types are the single source of truth for role strings in the app
- Navigation items respect role-based sidebar filtering decisions
- Role hierarchy helpers enable permission checks without DB calls
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-03-SUMMARY.md`
</output>
