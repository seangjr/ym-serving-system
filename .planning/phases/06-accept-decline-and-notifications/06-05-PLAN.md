---
phase: 06-accept-decline-and-notifications
plan: 05
type: execute
wave: 3
depends_on: ["06-01", "06-03"]
files_modified:
  - supabase/migrations/00010_reminder_cron.sql
  - app/api/reminders/route.ts
  - lib/notifications/reminders.ts
autonomous: true

must_haves:
  truths:
    - "Members receive reminder notifications before their service date based on their reminder_days_before preference"
    - "Reminders are sent only once per assignment (not duplicated on subsequent runs)"
    - "Members with reminder_days_before = 0 do not receive reminders"
    - "Reminder notifications include service name, position, date, and link to the service"
    - "Reminders skip declined assignments"
  artifacts:
    - path: "supabase/migrations/00010_reminder_cron.sql"
      provides: "pg_cron job definition for daily reminder generation (with setup instructions)"
    - path: "app/api/reminders/route.ts"
      provides: "API route that generates reminder notifications when called"
      exports: ["POST"]
    - path: "lib/notifications/reminders.ts"
      provides: "generateReminders() function with deduplication logic"
      exports: ["generateReminders"]
  key_links:
    - from: "supabase/migrations/00010_reminder_cron.sql"
      to: "app/api/reminders/route.ts"
      via: "pg_cron + pg_net calls the API route daily"
      pattern: "pg_net.*reminders"
    - from: "app/api/reminders/route.ts"
      to: "lib/notifications/reminders.ts"
      via: "calls generateReminders()"
      pattern: "generateReminders"
    - from: "lib/notifications/reminders.ts"
      to: "lib/notifications/send.ts"
      via: "createNotification for each reminder"
      pattern: "createNotification"
---

<objective>
Build the configurable reminder system that sends in-app notifications to members before their service date based on their personal reminder_days_before preference.

Purpose: This delivers NOTF-05 (configurable reminders before service date). Each member's `reminder_days_before` setting in `member_profiles` determines how many days in advance they receive a reminder. A daily cron job (pg_cron) triggers the reminder generation.

Output: A Next.js API route for generating reminders, a reminder generation function with deduplication, and a pg_cron migration for scheduling.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-accept-decline-and-notifications/06-RESEARCH.md
@.planning/phases/06-accept-decline-and-notifications/06-01-SUMMARY.md
@.planning/phases/06-accept-decline-and-notifications/06-03-SUMMARY.md
@lib/notifications/send.ts
@lib/notifications/types.ts
@lib/supabase/admin.ts
@supabase/migrations/00004_member_profiles.sql
@supabase/migrations/00009_notifications.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reminder generation function and API route</name>
  <files>
    lib/notifications/reminders.ts
    app/api/reminders/route.ts
  </files>
  <action>
**Create lib/notifications/reminders.ts:**

A server-side function that generates reminder notifications for upcoming services.

```typescript
export async function generateReminders(): Promise<{ created: number; skipped: number }>
```

Implementation:
1. Use createAdminClient() (bypasses RLS since this runs as a system job, not a user request)
2. Query upcoming service_assignments with their member's reminder preference:
   ```sql
   SELECT
     sa.id as assignment_id,
     sa.member_id,
     sa.status,
     sp.service_id,
     s.title as service_title,
     s.service_date,
     s.start_time,
     tp.name as position_name,
     mp.reminder_days_before
   FROM service_assignments sa
   JOIN service_positions sp ON sa.service_position_id = sp.id
   JOIN services s ON sp.service_id = s.id
   JOIN team_positions tp ON sp.position_id = tp.id
   JOIN member_profiles mp ON sa.member_id = mp.member_id
   WHERE sa.status != 'declined'
     AND s.is_cancelled = false
     AND s.service_date >= CURRENT_DATE
     AND s.service_date <= CURRENT_DATE + interval '14 days'
     AND mp.reminder_days_before > 0
   ```
   Use the Supabase admin client with raw RPC or build with query builder. Since the join is complex, use a raw SQL query via `admin.rpc()` or build step by step:
   - First fetch assignments for services in the next 14 days (max reminder window) that are not declined and not cancelled
   - Then for each, check if service_date - CURRENT_DATE = reminder_days_before

3. For each matching assignment, calculate if today is the right day:
   - Parse service_date, calculate `daysUntilService = differenceInCalendarDays(parseISO(serviceDate), new Date())`
   - If daysUntilService === member's reminder_days_before, this assignment needs a reminder

4. Deduplication check: for each candidate, check if a reminder notification already exists:
   ```
   SELECT 1 FROM notifications
   WHERE recipient_member_id = X
     AND type = 'reminder'
     AND metadata->>'assignment_id' = assignment_id::text
   ```
   If exists, skip (increment skipped counter). Use a single batch query: fetch all existing reminder notifications for the candidate assignment IDs, build a Set of already-reminded assignment IDs, then filter.

5. For each non-duplicate, call createNotification:
   - recipientMemberId: member_id
   - type: 'reminder'
   - title: "Serving Reminder"
   - body: "You are serving as {positionName} at {serviceTitle} on {formatted serviceDate}" (format as "Sun, 23 Feb 2026" using date-fns)
   - metadata: { assignmentId, serviceId }
   - actionUrl: `/services/${serviceId}`

6. Return { created: count of new reminders, skipped: count of duplicates }

Use date-fns for date calculations (differenceInCalendarDays, parseISO, format). All already installed.

**Create app/api/reminders/route.ts:**

A POST API route that triggers reminder generation. Secured with a secret key.

```typescript
import { generateReminders } from "@/lib/notifications/reminders";
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  // Verify authorization -- use a simple bearer token
  const authHeader = request.headers.get("authorization");
  const expectedToken = process.env.CRON_SECRET;

  // If CRON_SECRET is not set, allow in development only
  if (expectedToken && authHeader !== `Bearer ${expectedToken}`) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  if (!expectedToken && process.env.NODE_ENV === "production") {
    return NextResponse.json(
      { error: "CRON_SECRET not configured" },
      { status: 500 }
    );
  }

  try {
    const result = await generateReminders();
    return NextResponse.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error("Reminder generation failed:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

Add `CRON_SECRET` to `.env.local.example` with a comment explaining its purpose.

Note: Add `/api/reminders` to the middleware allow-list if the middleware currently blocks unauthenticated API requests. Check the middleware pattern -- if it already allows all `/api/*` routes, no change needed.
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Verify both files exist. Test the API route locally with `curl -X POST http://localhost:3000/api/reminders` (should work in dev without CRON_SECRET).</verify>
  <done>generateReminders() function fetches upcoming assignments, checks reminder_days_before preferences, deduplicates against existing notifications, and creates reminder notifications. API route is secured with CRON_SECRET bearer token and callable by pg_cron or external cron.</done>
</task>

<task type="auto">
  <name>Task 2: pg_cron migration for daily reminder scheduling</name>
  <files>
    supabase/migrations/00010_reminder_cron.sql
  </files>
  <action>
**Create supabase/migrations/00010_reminder_cron.sql:**

This migration documents the pg_cron setup for daily reminder generation. Because pg_cron and pg_net extensions must be enabled via the Supabase dashboard (they cannot be enabled via standard SQL migrations in all environments), this migration is primarily a documentation + setup verification file.

Content:
```sql
-- =============================================================================
-- Migration: 00010_reminder_cron
-- Purpose: Daily reminder notification generation via pg_cron + pg_net
-- =============================================================================
--
-- SETUP INSTRUCTIONS (requires Supabase Dashboard):
-- 1. Enable pg_cron extension: Database > Extensions > pg_cron > Enable
-- 2. Enable pg_net extension: Database > Extensions > pg_net > Enable
-- 3. Set CRON_SECRET env var in your deployment (Vercel, etc.)
-- 4. Run the following SQL in the Supabase SQL Editor to create the cron job:
--
--    SELECT cron.schedule(
--      'daily-reminders',
--      '0 8 * * *',  -- 8:00 AM UTC daily
--      $$
--        SELECT net.http_post(
--          url := 'https://YOUR_APP_URL/api/reminders',
--          headers := jsonb_build_object(
--            'Content-Type', 'application/json',
--            'Authorization', 'Bearer YOUR_CRON_SECRET'
--          ),
--          body := '{}'::jsonb
--        );
--      $$
--    );
--
-- To verify the job was created:
--    SELECT * FROM cron.job;
--
-- To remove the job:
--    SELECT cron.unschedule('daily-reminders');
--
-- =============================================================================

-- Alternative approach: Pure SQL reminder generation (no API route needed)
-- This runs entirely inside Postgres, creating notification rows directly.
-- Use this if you prefer not to rely on pg_net calling an API route.

-- NOTE: This function is created but NOT scheduled automatically.
-- Schedule it via the Supabase SQL Editor as documented above.

CREATE OR REPLACE FUNCTION public.generate_reminders()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_created int := 0;
  v_skipped int := 0;
  r record;
BEGIN
  FOR r IN
    SELECT
      sa.id AS assignment_id,
      sa.member_id,
      s.id AS service_id,
      s.title AS service_title,
      s.service_date,
      tp.name AS position_name,
      mp.reminder_days_before
    FROM service_assignments sa
    JOIN service_positions sp ON sa.service_position_id = sp.id
    JOIN services s ON sp.service_id = s.id
    JOIN team_positions tp ON sp.position_id = tp.id
    JOIN member_profiles mp ON sa.member_id = mp.member_id
    WHERE sa.status != 'declined'
      AND s.is_cancelled = false
      AND s.service_date = CURRENT_DATE + (mp.reminder_days_before || ' days')::interval
      AND mp.reminder_days_before > 0
  LOOP
    -- Check if reminder already sent for this assignment
    IF NOT EXISTS (
      SELECT 1 FROM notifications
      WHERE recipient_member_id = r.member_id
        AND type = 'reminder'
        AND metadata->>'assignment_id' = r.assignment_id::text
    ) THEN
      INSERT INTO notifications (recipient_member_id, type, title, body, metadata, action_url)
      VALUES (
        r.member_id,
        'reminder',
        'Serving Reminder',
        'You are serving as ' || r.position_name || ' at ' || r.service_title ||
          ' on ' || to_char(r.service_date, 'Dy, DD Mon YYYY'),
        jsonb_build_object('assignment_id', r.assignment_id, 'service_id', r.service_id),
        '/services/' || r.service_id
      );
      v_created := v_created + 1;
    ELSE
      v_skipped := v_skipped + 1;
    END IF;
  END LOOP;

  RETURN jsonb_build_object('created', v_created, 'skipped', v_skipped);
END;
$$;

-- Grant execute to authenticated (for testing via RPC) and service_role
GRANT EXECUTE ON FUNCTION public.generate_reminders() TO authenticated;
GRANT EXECUTE ON FUNCTION public.generate_reminders() TO service_role;

-- Add a comment for discoverability
COMMENT ON FUNCTION public.generate_reminders() IS
  'Generates reminder notifications for upcoming service assignments based on each member''s reminder_days_before preference. Safe to call multiple times (deduplicates). Schedule via pg_cron: SELECT cron.schedule(''daily-reminders'', ''0 8 * * *'', $$SELECT public.generate_reminders()$$);';

-- =============================================================================
-- Notification cleanup job (optional, run monthly)
-- =============================================================================
-- To prevent unbounded growth of the notifications table, schedule a cleanup:
--
--    SELECT cron.schedule(
--      'cleanup-old-notifications',
--      '0 3 1 * *',  -- 3:00 AM UTC on the 1st of each month
--      $$DELETE FROM public.notifications WHERE created_at < now() - interval '90 days'$$
--    );
-- =============================================================================
```

The migration creates a `generate_reminders()` Postgres function that can be called directly by pg_cron (simpler than the pg_net approach since it does not require an external HTTP call). The API route from Task 1 serves as an alternative trigger mechanism (useful for Vercel Cron or manual testing).

The pg_cron scheduling itself is documented as setup instructions since pg_cron extension enablement varies by environment.
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Read the migration file to verify it has valid SQL syntax with the generate_reminders() function, deduplication logic, and clear setup instructions.</verify>
  <done>Migration file creates generate_reminders() Postgres function with per-member reminder_days_before preference matching, deduplication via NOT EXISTS check, and clear pg_cron scheduling instructions. API route provides alternative trigger mechanism for environments without pg_cron. Both approaches produce identical reminder notifications.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds
2. lib/notifications/reminders.ts exports generateReminders() function
3. app/api/reminders/route.ts responds to POST requests
4. supabase/migrations/00010_reminder_cron.sql has valid generate_reminders() function
5. Deduplication prevents duplicate reminders (NOT EXISTS check in both SQL and TypeScript implementations)
6. Members with reminder_days_before = 0 are excluded
7. Declined assignments are excluded
8. Cancelled services are excluded
9. CRON_SECRET documented in .env.local.example
</verification>

<success_criteria>
- Two trigger mechanisms available: Postgres function (for pg_cron) and API route (for external cron/manual)
- Both implementations produce identical results
- Deduplication is robust: same reminder never sent twice for the same assignment
- Reminder text includes position name, service title, and formatted date
- Security: API route requires CRON_SECRET in production
- Setup instructions are clear and self-contained in the migration file
</success_criteria>

<output>
After completion, create `.planning/phases/06-accept-decline-and-notifications/06-05-SUMMARY.md`
</output>
