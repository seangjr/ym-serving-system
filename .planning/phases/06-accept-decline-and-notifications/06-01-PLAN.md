---
phase: 06-accept-decline-and-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00009_notifications.sql
  - lib/notifications/types.ts
  - lib/notifications/schemas.ts
  - lib/notifications/queries.ts
  - lib/notifications/actions.ts
  - lib/notifications/providers.ts
  - lib/notifications/send.ts
autonomous: true
requirements: [NOTF-01, NOTF-02, NOTF-03]

must_haves:
  truths:
    - "Notifications table exists with type, recipient, title, body, metadata, action_url, is_read columns"
    - "Swap requests table exists with pre-arranged model columns (requester, accepted_by set at creation)"
    - "NotificationProvider interface is defined and InAppProvider implementation writes to notifications table"
    - "createNotification() function sends via all registered providers"
    - "RLS policies allow users to read only their own notifications"
    - "Realtime publication is enabled on notifications table"
  artifacts:
    - path: "supabase/migrations/00009_notifications.sql"
      provides: "notifications + swap_requests tables, RLS, indexes, Realtime publication"
      contains: "notifications"
    - path: "lib/notifications/types.ts"
      provides: "NotificationType enum, Notification interface, SwapRequest types"
      exports: ["NotificationType", "Notification", "SwapRequest", "SwapRequestStatus"]
    - path: "lib/notifications/providers.ts"
      provides: "NotificationProvider interface + InAppProvider class"
      exports: ["NotificationProvider", "NotificationPayload", "InAppProvider"]
    - path: "lib/notifications/send.ts"
      provides: "createNotification() central function"
      exports: ["createNotification"]
    - path: "lib/notifications/queries.ts"
      provides: "getNotifications, getUnreadCount query functions"
      exports: ["getNotifications", "getUnreadCount"]
    - path: "lib/notifications/actions.ts"
      provides: "markAsRead, markAllRead server actions"
      exports: ["markAsRead", "markAllRead"]
    - path: "lib/notifications/schemas.ts"
      provides: "Zod schemas for notification actions"
      exports: ["markAsReadSchema", "markAllReadSchema"]
  key_links:
    - from: "lib/notifications/send.ts"
      to: "lib/notifications/providers.ts"
      via: "InAppProvider.send() call"
      pattern: "InAppProvider"
    - from: "lib/notifications/providers.ts"
      to: "supabase/migrations/00009_notifications.sql"
      via: "INSERT into notifications table"
      pattern: "notifications.*insert"
---

<objective>
Create the notification system foundation: database tables (notifications + swap_requests), provider-extensible architecture, and core lib/notifications module with types, queries, actions, and the central createNotification() function.

Purpose: All subsequent plans (accept/decline, notification UI, swaps, reminders) depend on this notification infrastructure. The provider pattern satisfies NOTF-03 (extensible for future Telegram/WhatsApp).
Output: Migration 00009, complete lib/notifications/ module ready for consumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-accept-decline-and-notifications/06-RESEARCH.md
@.planning/phases/06-accept-decline-and-notifications/06-CONTEXT.md
@lib/assignments/actions.ts
@lib/assignments/types.ts
@supabase/migrations/00004_member_profiles.sql
@lib/supabase/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for notifications and swap_requests tables</name>
  <files>supabase/migrations/00009_notifications.sql</files>
  <action>
Create migration 00009_notifications.sql with:

1. **notifications table:**
   - id uuid PK default gen_random_uuid()
   - recipient_member_id uuid NOT NULL FK -> members(id) ON DELETE CASCADE
   - type text NOT NULL CHECK (type IN ('assignment_new', 'assignment_changed', 'assignment_declined', 'swap_requested', 'swap_approved', 'swap_rejected', 'reminder'))
   - title text NOT NULL
   - body text NOT NULL
   - metadata jsonb NOT NULL DEFAULT '{}'
   - action_url text
   - is_read boolean NOT NULL DEFAULT false
   - created_at timestamptz NOT NULL DEFAULT now()

2. **Indexes:**
   - (recipient_member_id, is_read, created_at DESC) for unread-first queries
   - (recipient_member_id, created_at DESC) for all-notifications queries

3. **RLS policies:**
   - SELECT: authenticated users can view own notifications (recipient_member_id matches their member record via auth.uid())
   - UPDATE: authenticated users can update own notifications (for marking read)
   - DELETE: authenticated users can delete own notifications
   - No INSERT policy for authenticated -- inserts done via admin client (server-side)

4. **Realtime publication:**
   - ALTER PUBLICATION supabase_realtime ADD TABLE public.notifications;
   - ALTER TABLE public.notifications REPLICA IDENTITY FULL; (needed for UPDATE/DELETE payloads)

5. **swap_requests table** (pre-arranged model per user decision):
   - id uuid PK default gen_random_uuid()
   - assignment_id uuid NOT NULL FK -> service_assignments(id) ON DELETE CASCADE
   - requester_member_id uuid NOT NULL FK -> members(id) ON DELETE CASCADE
   - target_member_id uuid NOT NULL FK -> members(id) ON DELETE CASCADE (the pre-arranged swap partner -- set at creation, NOT nullable)
   - status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'cancelled'))
   - reason text (optional)
   - resolved_by uuid FK -> members(id) ON DELETE SET NULL
   - resolved_at timestamptz
   - created_at timestamptz NOT NULL DEFAULT now()
   - updated_at timestamptz NOT NULL DEFAULT now()

   NOTE: The swap state machine is simplified per user decision (pre-arranged model):
   - No 'accepted' state (partner is pre-selected, no acceptance step)
   - No 'expired' state (simpler for v1)
   - Column is target_member_id (NOT accepted_by_member_id) since the partner is chosen upfront

6. **swap_requests indexes:**
   - (assignment_id) for finding swaps for an assignment
   - (status) WHERE status = 'pending' for pending swap queries
   - UNIQUE (assignment_id, status) WHERE status = 'pending' to prevent multiple pending swaps per assignment

7. **swap_requests RLS:**
   - SELECT: authenticated users can view swap requests where they are requester, target, or a team lead for the assignment's team
   - No INSERT/UPDATE/DELETE for authenticated -- done via admin client

8. **updated_at trigger** for swap_requests using existing update_updated_at_column() function.
  </action>
  <verify>Run `supabase db push` or apply migration. Verify tables exist with correct columns, indexes, and policies. Check that notifications table is in supabase_realtime publication.</verify>
  <done>Both tables created with all columns, indexes, RLS policies, Realtime publication enabled on notifications, and updated_at trigger on swap_requests.</done>
</task>

<task type="auto">
  <name>Task 2: lib/notifications module -- types, schemas, providers, queries, actions, send</name>
  <files>lib/notifications/types.ts, lib/notifications/schemas.ts, lib/notifications/queries.ts, lib/notifications/actions.ts, lib/notifications/providers.ts, lib/notifications/send.ts</files>
  <action>
Create the complete lib/notifications/ module following existing codebase patterns (see lib/assignments/ for reference):

**types.ts:**
- NotificationType union type: 'assignment_new' | 'assignment_changed' | 'assignment_declined' | 'swap_requested' | 'swap_approved' | 'swap_rejected' | 'reminder'
- Notification interface: id, recipientMemberId, type, title, body, metadata (Record<string, unknown>), actionUrl, isRead, createdAt
- SwapRequestStatus union: 'pending' | 'approved' | 'rejected' | 'cancelled'
- SwapRequest interface: id, assignmentId, requesterMemberId, requesterName, targetMemberId, targetName, status, reason, resolvedBy, resolvedAt, createdAt, updatedAt
- NotificationWithAction: extends Notification with optional quickAction field for toast rendering

**schemas.ts:**
- markAsReadSchema: z.object({ notificationId: z.string().uuid() })
- markAllReadSchema: z.object({}) (no fields needed)
- respondToAssignmentSchema: z.object({ assignmentId: z.string().uuid(), status: z.enum(['confirmed', 'declined']) })
- requestSwapSchema: z.object({ assignmentId: z.string().uuid(), targetMemberId: z.string().uuid(), reason: z.union([z.string().max(500), z.literal('')]).optional() })
- resolveSwapSchema: z.object({ swapRequestId: z.string().uuid(), action: z.enum(['approved', 'rejected']) })

**providers.ts:**
- NotificationPayload interface: recipientMemberId, type (NotificationType), title, body, metadata?, actionUrl?
- NotificationProvider interface: name (string), send(payload: NotificationPayload): Promise<void>
- InAppProvider class implementing NotificationProvider:
  - name = 'in_app'
  - send() inserts into notifications table via createAdminClient()
- Export getProviders() that returns [new InAppProvider()] -- future providers (Email, Telegram) added here

**send.ts:**
- createNotification(payload: NotificationPayload): Promise<void>
  - Gets providers from getProviders()
  - Calls each provider.send(payload) in parallel (Promise.all)
  - Wraps in try/catch with console.error on failure (notification failure should not break the calling action)
- This is the SINGLE entry point for all notification sending throughout the app

**queries.ts (server-only, uses RLS client):**
- getNotifications(limit?: number): Promise<Notification[]> -- fetch notifications for current user, ordered by created_at DESC, default limit 20
- getUnreadCount(): Promise<number> -- count unread notifications for current user
- getMyAssignments(): Promise<MyAssignment[]> -- fetch upcoming assignments for the logged-in member with service details (service title, date, start_time, end_time, position name, team name, status, assignment id, service id). Filter: service_date >= today. Order by service_date ASC, start_time ASC. This query powers the My Schedule page.
- getSwapRequestsForAssignment(assignmentId: string): Promise<SwapRequest[]>
- getPendingSwapsForTeamLead(memberId: string): Promise<SwapRequest[]> -- swaps where the team lead needs to approve

Define MyAssignment type in types.ts: id, memberId, serviceId, serviceTitle, serviceDate, startTime, endTime, positionName, teamName, teamColor, status, notes

**actions.ts (server actions):**
- markAsRead(data: unknown): server action, validates with markAsReadSchema, updates is_read=true on the notification via admin client (after verifying ownership)
- markAllRead(): server action, updates all unread notifications for the caller to is_read=true via admin client

Follow the established server action pattern:
1. Create RLS client, getUserRole
2. Parse + validate with Zod
3. Authorize (verify caller is recipient)
4. Execute with admin client
5. Revalidate path
6. Return { success: true } | { error: string }
  </action>
  <verify>Run `pnpm build` to verify all files compile without errors. Check that types, schemas, providers, queries, actions, and send.ts all export correctly and have no circular dependencies.</verify>
  <done>Complete lib/notifications/ module with 6 files, all compiling, following established server action and query patterns. createNotification() is the central notification dispatch function. getMyAssignments() query is ready for My Schedule page consumption.</done>
</task>

</tasks>

<verification>
- `pnpm build` passes without errors
- Migration 00009 creates both tables with correct schema
- lib/notifications/ exports are importable from other modules
- InAppProvider.send() correctly inserts into notifications table
- getNotifications/getUnreadCount query via RLS (user sees only own)
</verification>

<success_criteria>
- notifications table exists with all columns, indexes, RLS, and Realtime publication
- swap_requests table exists with pre-arranged model (target_member_id NOT NULL)
- NotificationProvider interface defined with InAppProvider implementation
- createNotification() dispatches to all registered providers
- getMyAssignments() query returns upcoming assignments for a member
- All 6 lib/notifications/ files compile and follow codebase conventions
</success_criteria>

<output>
After completion, create `.planning/phases/06-accept-decline-and-notifications/06-01-SUMMARY.md`
</output>
