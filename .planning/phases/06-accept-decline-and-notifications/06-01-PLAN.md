---
phase: 06-accept-decline-and-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00009_notifications.sql
  - lib/notifications/types.ts
  - lib/notifications/schemas.ts
  - lib/notifications/queries.ts
  - lib/notifications/actions.ts
  - lib/notifications/providers.ts
  - lib/notifications/send.ts
autonomous: true
requirements:
  - NOTF-03

must_haves:
  truths:
    - "Notification system has provider-extensible architecture (InAppProvider first, others addable later)"
    - "notifications table exists with type, recipient, read status, metadata, and action_url"
    - "swap_requests table exists with full state machine (pending/accepted/approved/rejected/cancelled/expired)"
    - "Notifications table is published to Supabase Realtime for live CDC subscriptions"
  artifacts:
    - path: "supabase/migrations/00009_notifications.sql"
      provides: "notifications + swap_requests tables with RLS, indexes, Realtime publication"
      contains: "ALTER PUBLICATION supabase_realtime ADD TABLE"
    - path: "lib/notifications/providers.ts"
      provides: "NotificationProvider interface + InAppProvider implementation"
      exports: ["InAppProvider", "NotificationProvider"]
    - path: "lib/notifications/send.ts"
      provides: "Central createNotification function that calls all providers"
      exports: ["createNotification"]
    - path: "lib/notifications/types.ts"
      provides: "NotificationType enum, Notification interface, SwapRequest types"
    - path: "lib/notifications/schemas.ts"
      provides: "Zod validation schemas for notification actions"
    - path: "lib/notifications/queries.ts"
      provides: "getNotifications, getUnreadCount queries"
    - path: "lib/notifications/actions.ts"
      provides: "markAsRead, markAllAsRead server actions"
  key_links:
    - from: "lib/notifications/send.ts"
      to: "lib/notifications/providers.ts"
      via: "InAppProvider instantiation"
      pattern: "new InAppProvider"
    - from: "lib/notifications/providers.ts"
      to: "supabase/migrations/00009_notifications.sql"
      via: "admin client insert into notifications table"
      pattern: "from.*notifications.*insert"
---

<objective>
Create the notification system foundation: database tables (notifications + swap_requests) and the provider-extensible lib/notifications module.

Purpose: Every other plan in Phase 6 depends on the ability to create and query notifications. This plan lays the database and TypeScript infrastructure so that Plans 02-05 can emit and display notifications without building their own plumbing.

Output: Migration file, 6 TypeScript module files in lib/notifications/
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-accept-decline-and-notifications/06-RESEARCH.md
@supabase/migrations/00004_member_profiles.sql
@supabase/migrations/00006_assignments.sql
@lib/supabase/admin.ts
@lib/assignments/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notifications + swap_requests migration</name>
  <files>supabase/migrations/00009_notifications.sql</files>
  <action>
Create migration file `supabase/migrations/00009_notifications.sql` with:

**notifications table:**
- `id` uuid PK default gen_random_uuid()
- `recipient_member_id` uuid NOT NULL FK -> members(id) ON DELETE CASCADE
- `type` text NOT NULL CHECK (type IN ('assignment_new', 'assignment_changed', 'assignment_declined', 'assignment_confirmed', 'swap_requested', 'swap_accepted', 'swap_approved', 'swap_rejected', 'reminder'))
- `title` text NOT NULL
- `body` text NOT NULL
- `metadata` jsonb NOT NULL DEFAULT '{}'
- `action_url` text
- `is_read` boolean NOT NULL DEFAULT false
- `created_at` timestamptz NOT NULL DEFAULT now()

**Indexes on notifications:**
- `idx_notifications_recipient_unread` on (recipient_member_id, is_read, created_at DESC) -- for unread badge count
- `idx_notifications_recipient_created` on (recipient_member_id, created_at DESC) -- for notification list

**RLS on notifications:**
- Enable RLS
- SELECT policy: authenticated users can view own notifications (recipient_member_id matches their member record via members.auth_user_id = auth.uid())
- UPDATE policy: authenticated users can update own notifications (for marking as read)
- INSERT policy: allow service_role only (notifications created server-side via admin client)

**Realtime publication:**
- `ALTER PUBLICATION supabase_realtime ADD TABLE public.notifications;`

**swap_requests table:**
- `id` uuid PK default gen_random_uuid()
- `assignment_id` uuid NOT NULL FK -> service_assignments(id) ON DELETE CASCADE
- `requester_member_id` uuid NOT NULL FK -> members(id) ON DELETE CASCADE
- `accepted_by_member_id` uuid FK -> members(id) ON DELETE SET NULL
- `status` text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'approved', 'rejected', 'cancelled', 'expired'))
- `reason` text
- `resolved_by` uuid FK -> members(id) ON DELETE SET NULL
- `resolved_at` timestamptz
- `created_at` timestamptz NOT NULL DEFAULT now()
- `updated_at` timestamptz NOT NULL DEFAULT now()

**Indexes on swap_requests:**
- `idx_swap_requests_assignment` on (assignment_id)
- `idx_swap_requests_status` on (status) WHERE status = 'pending' (partial index)

**RLS on swap_requests:**
- Enable RLS
- SELECT: authenticated users can view swap requests where they are requester, accepted_by, or the team lead for the assignment's team
- INSERT: authenticated users can create swap requests for their own assignments
- UPDATE: service_role only (state transitions managed server-side)

**updated_at trigger** on swap_requests using existing `public.update_updated_at_column()` function.

**Cleanup job comment:** Add a SQL comment noting that a pg_cron job for 90-day notification cleanup will be added in Plan 06-05 (reminders plan).
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Verify migration file exists and contains both tables, RLS policies, indexes, and the Realtime publication ALTER statement.</verify>
  <done>00009_notifications.sql exists with notifications table (8 columns + RLS + 2 indexes + Realtime publication) and swap_requests table (10 columns + RLS + 2 indexes + updated_at trigger)</done>
</task>

<task type="auto">
  <name>Task 2: Create lib/notifications module (types, schemas, providers, send, queries, actions)</name>
  <files>
    lib/notifications/types.ts
    lib/notifications/schemas.ts
    lib/notifications/providers.ts
    lib/notifications/send.ts
    lib/notifications/queries.ts
    lib/notifications/actions.ts
  </files>
  <action>
Create the `lib/notifications/` module with 6 files:

**types.ts:**
- `NotificationType` union type: 'assignment_new' | 'assignment_changed' | 'assignment_declined' | 'assignment_confirmed' | 'swap_requested' | 'swap_accepted' | 'swap_approved' | 'swap_rejected' | 'reminder'
- `Notification` interface: id, recipientMemberId, type, title, body, metadata (Record<string, unknown>), actionUrl (string | null), isRead, createdAt
- `SwapRequestStatus` union type: 'pending' | 'accepted' | 'approved' | 'rejected' | 'cancelled' | 'expired'
- `SwapRequest` interface: id, assignmentId, requesterMemberId, requesterName, acceptedByMemberId (null), acceptedByName (null), status, reason (null), resolvedBy (null), resolvedAt (null), createdAt, updatedAt
- `NotificationPayload` interface: recipientMemberId, type, title, body, metadata? (Record<string, unknown>), actionUrl? (string)

**schemas.ts:**
- `respondToAssignmentSchema`: z.object({ assignmentId: uuid, status: z.enum(['confirmed', 'declined']) })
- `markAsReadSchema`: z.object({ notificationId: uuid })
- `requestSwapSchema`: z.object({ assignmentId: uuid, reason: z.union([z.string().max(500), z.literal('')]).optional() })
- `acceptSwapSchema`: z.object({ swapRequestId: uuid })
- `resolveSwapSchema`: z.object({ swapRequestId: uuid, action: z.enum(['approve', 'reject']) })
- Export inferred types for all schemas

**providers.ts:**
- `NotificationProvider` interface with `name: string` and `send(payload: NotificationPayload): Promise<void>`
- `InAppProvider` class implementing NotificationProvider:
  - name = 'in_app'
  - send() inserts into notifications table using createAdminClient()
  - Maps payload fields to DB columns: recipient_member_id, type, title, body, metadata, action_url
- Export both the interface and InAppProvider class

**send.ts:** (mark with "use server" -- it's a server-only module, NOT a server action file)
- Import `server-only` at top to prevent client import
- `providers` array: `[new InAppProvider()]`
- `createNotification(payload: NotificationPayload): Promise<void>` -- iterates over providers, calls send() on each, wraps in try/catch to prevent one provider failure from blocking others (log error via console.error)
- Export createNotification

**queries.ts:** (server-only via import "server-only")
- `getNotifications(memberId: string, limit?: number): Promise<Notification[]>` -- fetches from notifications table where recipient_member_id = memberId, ordered by created_at DESC, limit defaults to 50. Uses RLS client (createClient from server).
- `getUnreadCount(memberId: string): Promise<number>` -- count query on notifications where recipient_member_id = memberId AND is_read = false. Uses RLS client.

**actions.ts:** ("use server")
- `markAsRead(data: unknown)` -- validates with markAsReadSchema, gets caller's memberId, updates is_read = true on the notification where id = notificationId. Uses admin client but verifies ownership (recipient_member_id = callerId). Returns { success: true } | { error: string }.
- `markAllAsRead()` -- gets caller's memberId, updates is_read = true on all unread notifications for this member. Uses admin client. Returns { success: true } | { error: string }.

Follow the established server action pattern from lib/assignments/actions.ts: create RLS client -> getUserRole -> validate -> admin client -> execute -> return result.
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Run `pnpm lint` to check for Biome issues. Verify all 6 files exist in lib/notifications/ and that send.ts exports createNotification, providers.ts exports InAppProvider.</verify>
  <done>lib/notifications/ module exists with 6 files. createNotification() dispatches to InAppProvider which inserts into notifications table. Queries fetch notifications and unread count. Actions handle mark-as-read. Provider interface allows adding new channels (email, Telegram, WhatsApp) by implementing NotificationProvider and adding to providers array.</done>
</task>

</tasks>

<verification>
- `pnpm build` passes with no errors
- `pnpm lint` passes
- supabase/migrations/00009_notifications.sql exists with both tables
- lib/notifications/ has 6 files: types.ts, schemas.ts, providers.ts, send.ts, queries.ts, actions.ts
- send.ts has "server-only" import and exports createNotification
- providers.ts exports NotificationProvider interface and InAppProvider class
- schemas.ts exports respondToAssignmentSchema (used in Plan 06-02)
</verification>

<success_criteria>
- Notification infrastructure is complete and ready for Plans 02-05 to use
- createNotification(payload) can be called from any server action to dispatch a notification
- Provider-extensible architecture satisfies NOTF-03 (new providers addable without changing core logic)
- Database tables ready for Realtime subscription (publication configured)
</success_criteria>

<output>
After completion, create `.planning/phases/06-accept-decline-and-notifications/06-01-SUMMARY.md`
</output>
