---
phase: 06-accept-decline-and-notifications
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - lib/notifications/actions.ts
  - lib/notifications/queries.ts
  - lib/notifications/types.ts
  - app/(app)/my-schedule/swap-request-dialog.tsx
  - app/(app)/my-schedule/schedule-list.tsx
  - app/(app)/services/[serviceId]/swap-approval-list.tsx
  - app/(app)/services/[serviceId]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Member can request a swap from their assignment on the My Schedule page"
    - "Requesting a swap notifies eligible members (same position skill) via in-app notification"
    - "Another member can accept a swap request from their notification or My Schedule"
    - "Team lead sees pending swap requests on the service detail page and can approve or reject"
    - "Approved swap reassigns the position from requester to acceptor"
    - "Rejected swap notifies both requester and acceptor"
    - "Swap request can be cancelled by the requester before acceptance"
  artifacts:
    - path: "lib/notifications/actions.ts"
      provides: "requestSwap, acceptSwap, approveSwap, cancelSwap server actions"
      exports: ["requestSwap", "acceptSwap", "approveSwap", "cancelSwap"]
    - path: "lib/notifications/queries.ts"
      provides: "getSwapRequestsForService, getSwapRequestsForMember query functions"
      exports: ["getSwapRequestsForService", "getSwapRequestsForMember"]
    - path: "app/(app)/my-schedule/swap-request-dialog.tsx"
      provides: "Dialog for requesting a swap with optional reason"
    - path: "app/(app)/services/[serviceId]/swap-approval-list.tsx"
      provides: "Team lead view of pending swap requests with approve/reject buttons"
  key_links:
    - from: "app/(app)/my-schedule/swap-request-dialog.tsx"
      to: "lib/notifications/actions.ts"
      via: "requestSwap server action call"
      pattern: "requestSwap"
    - from: "lib/notifications/actions.ts"
      to: "lib/notifications/send.ts"
      via: "createNotification on swap events"
      pattern: "createNotification"
    - from: "app/(app)/services/[serviceId]/swap-approval-list.tsx"
      to: "lib/notifications/actions.ts"
      via: "approveSwap server action call"
      pattern: "approveSwap"
---

<objective>
Build the swap request workflow: members can request swaps, eligible members can accept, and team leads can approve or reject.

Purpose: This delivers RESP-03 (member can request a swap, system notifies eligible members) and RESP-04 (team lead can approve or reject swap requests). The swap_requests table schema already exists from 06-01.

Output: Server actions for the full swap state machine (request, accept, approve, reject, cancel), swap request dialog on My Schedule, and swap approval list on the service detail page.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-accept-decline-and-notifications/06-RESEARCH.md
@.planning/phases/06-accept-decline-and-notifications/06-01-SUMMARY.md
@.planning/phases/06-accept-decline-and-notifications/06-02-SUMMARY.md
@.planning/phases/06-accept-decline-and-notifications/06-03-SUMMARY.md
@lib/notifications/types.ts
@lib/notifications/schemas.ts
@lib/notifications/actions.ts
@lib/notifications/queries.ts
@lib/notifications/send.ts
@lib/assignments/types.ts
@lib/assignments/queries.ts
@lib/assignments/actions.ts
@lib/auth/roles.ts
@lib/supabase/admin.ts
@app/(app)/my-schedule/page.tsx
@app/(app)/my-schedule/schedule-list.tsx
@app/(app)/services/[serviceId]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Swap request server actions and queries</name>
  <files>
    lib/notifications/actions.ts
    lib/notifications/queries.ts
    lib/notifications/types.ts
  </files>
  <action>
**Add swap queries to lib/notifications/queries.ts** (append to existing file):

`getSwapRequestsForService(serviceId: string)`: query swap_requests joined through service_assignments -> service_positions WHERE service_positions.service_id = serviceId. Include: swap request id, status, reason, requester name (join members via requester_member_id), accepted_by name (join members via accepted_by_member_id if not null), position name (join team_positions via service_positions -> service_assignments), created_at, updated_at. Order by created_at DESC. Returns SwapRequest[].

`getSwapRequestsForMember(memberId: string)`: query swap_requests WHERE requester_member_id = memberId OR the member is eligible (has pending swap requests for positions they have skills in). For simplicity, just fetch swap_requests WHERE requester_member_id = memberId AND status IN ('pending', 'accepted'). Returns SwapRequest[].

`getActiveSwapForAssignment(assignmentId: string)`: query swap_requests WHERE assignment_id = assignmentId AND status IN ('pending', 'accepted'). Returns SwapRequest | null. Used to check if an assignment already has a pending swap.

Both use RLS-protected client (createClient from server.ts).

**Add swap server actions to lib/notifications/actions.ts** (append to existing file):

1. `requestSwap(data: unknown)`:
   - Parse with requestSwapSchema: { assignmentId, reason? }
   - Verify ownership: SELECT from service_assignments WHERE id = assignmentId AND member_id = callerId
   - Check no existing active swap: query swap_requests WHERE assignment_id = assignmentId AND status IN ('pending', 'accepted'). If exists, return { error: "A swap request already exists for this assignment." }
   - INSERT into swap_requests: assignment_id, requester_member_id = callerId, reason, status = 'pending'
   - Find eligible members: get the position_id from service_positions (via assignment), then query member_position_skills WHERE position_id = X to find all members with that skill. Exclude the requester and any members already assigned to the same service.
   - For each eligible member, call createNotification with type 'swap_requested', title "Swap Request", body "{requesterName} is looking for a swap for {positionName} at {serviceName} on {serviceDate}", metadata { swapRequestId, assignmentId, serviceId }, actionUrl `/my-schedule`
   - revalidatePath('/my-schedule')
   - Return { success: true }

2. `acceptSwap(data: unknown)`:
   - Parse with respondToSwapSchema: { swapRequestId, accept: true }
   - Fetch the swap request, verify it is still 'pending'
   - Verify the acceptor (callerId) is NOT the requester
   - Use atomic UPDATE: `admin.from('swap_requests').update({ accepted_by_member_id: callerId, status: 'accepted', updated_at: new Date().toISOString() }).eq('id', swapRequestId).eq('status', 'pending')` -- if zero rows updated, someone else already accepted
   - Check the update result: if no rows affected, return { error: "Swap already accepted or no longer available." }
   - Notify the team lead: find team_id from assignment -> service_positions, then team lead from team_members WHERE team_id = X AND role = 'lead'. createNotification type 'swap_accepted', title "Swap Accepted", body "{acceptorName} accepted {requesterName}'s swap request for {positionName}", actionUrl `/services/${serviceId}`
   - Notify the requester: createNotification type 'swap_accepted', title "Swap Accepted", body "{acceptorName} accepted your swap request for {positionName}. Awaiting team lead approval."
   - revalidatePath('/my-schedule')
   - Return { success: true }

3. `approveSwap(data: unknown)`:
   - Parse with approveSwapSchema: { swapRequestId, approve: boolean }
   - Verify caller is team lead or admin/committee for the relevant team
   - Fetch the swap request, verify status is 'accepted'
   - If approve = true:
     - Execute the swap: UPDATE service_assignments SET member_id = accepted_by_member_id WHERE id = assignment_id
     - UPDATE swap_requests SET status = 'approved', resolved_by = callerId, resolved_at = now()
     - Notify both requester and acceptor: type 'swap_approved', title "Swap Approved", body "Your swap for {positionName} at {serviceName} has been approved"
   - If approve = false:
     - UPDATE swap_requests SET status = 'rejected', resolved_by = callerId, resolved_at = now()
     - Notify both requester and acceptor: type 'swap_rejected', title "Swap Rejected", body "The swap request for {positionName} at {serviceName} has been rejected"
   - revalidatePath for both /my-schedule and /services/${serviceId}
   - Return { success: true }

4. `cancelSwap(data: unknown)`:
   - Parse: z.object({ swapRequestId: z.string().uuid() })
   - Verify the caller is the requester (swap_requests.requester_member_id = callerId)
   - Verify status is 'pending' (can only cancel before acceptance)
   - UPDATE swap_requests SET status = 'cancelled', updated_at = now()
   - revalidatePath('/my-schedule')
   - Return { success: true }

Add `fetchSwapRequestsForMember()` and `fetchActiveSwapForAssignment(assignmentId: string)` server action wrappers for client components.

**Update lib/notifications/types.ts** if needed:
- Ensure SwapRequest type includes all fields needed by the UI: id, assignmentId, requesterMemberId, requesterName, acceptedByMemberId, acceptedByName, status, reason, resolvedBy, resolvedAt, createdAt, updatedAt, plus serviceName, positionName, serviceDate for display context.
- Add `SwapRequestWithContext` type that extends SwapRequest with service/position display data.
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Verify new functions are exported from the module.</verify>
  <done>Four swap server actions (requestSwap, acceptSwap, approveSwap, cancelSwap) exist with full state machine transitions, notification dispatch, and race condition protection on acceptance. Query functions for swap requests available.</done>
</task>

<task type="auto">
  <name>Task 2: Swap request UI on My Schedule and service detail page</name>
  <files>
    app/(app)/my-schedule/swap-request-dialog.tsx
    app/(app)/my-schedule/schedule-list.tsx
    app/(app)/services/[serviceId]/swap-approval-list.tsx
    app/(app)/services/[serviceId]/page.tsx
  </files>
  <action>
**Create app/(app)/my-schedule/swap-request-dialog.tsx** ("use client"):

A dialog for requesting a swap from the My Schedule page.

Props: `{ assignmentId: string; positionName: string; serviceName: string; open: boolean; onOpenChange: (open: boolean) => void }`

- Uses AlertDialog (consistent with ConflictDialog and UnavailabilityDialog patterns)
- Content: "Request a swap for your {positionName} assignment at {serviceName}?"
- Optional reason textarea (max 500 chars): "Reason (optional)" placeholder "Let others know why you need a swap..."
- Action buttons: "Cancel" (secondary) and "Request Swap" (amber/warning, matching the swap icon colour)
- On submit: call requestSwap({ assignmentId, reason }) server action
- Show loading state via useTransition
- On success: toast "Swap request sent. Eligible members have been notified." and close dialog
- On error: toast error message

**Modify app/(app)/my-schedule/schedule-list.tsx:**

Add a "Request Swap" button/icon to each assignment card:
- Only show for assignments with status 'confirmed' or 'pending' (no swap for already-declined)
- Icon: ArrowLeftRight from lucide-react
- Button placement: alongside or below the confirm/decline buttons
- If an active swap exists for this assignment (pass `hasActiveSwap` boolean from page), show "Swap Pending" text instead of the button (disabled state, amber text)
- Clicking opens the SwapRequestDialog
- If assignment has a swap that was accepted and awaiting approval, show "Swap Awaiting Approval" in amber

The page.tsx for my-schedule should be updated to also fetch active swap requests for each assignment. In the server component, after fetching assignments via getMyAssignments, call getActiveSwapForAssignment for each assignment (or batch via a new query that fetches all active swaps for a member's assignments).

Also show incoming swap requests on My Schedule: if there are any pending swap_requests where the current member is eligible (notified), show a section "Swap Requests" at the top with cards showing "X needs a swap for {position} at {service}" with an "Accept" button. When accepted, show "Awaiting Approval" state.

**Create app/(app)/services/[serviceId]/swap-approval-list.tsx** ("use client"):

A component showing pending swap requests for a service, visible to team leads and admin/committee.

Props: `{ swapRequests: SwapRequestWithContext[]; }`

- Show only if there are swap requests with status 'accepted' (awaiting approval)
- Card for each: "{requesterName} wants to swap {positionName} with {acceptedByName}"
- Reason shown if provided (text-sm text-muted-foreground)
- Two buttons: "Approve" (green) and "Reject" (destructive outline)
- Use useTransition for loading state
- On approve/reject: call approveSwap({ swapRequestId, approve: true/false })
- Toast on success: "Swap approved" / "Swap rejected"

**Modify app/(app)/services/[serviceId]/page.tsx:**

In the server component, fetch swap requests for this service via getSwapRequestsForService. Pass to a new SwapApprovalList component, shown above or below the AssignmentPanel. Only render if the user is admin/committee or team lead for the relevant team.
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Visit /my-schedule and verify swap request button appears on assignment cards.</verify>
  <done>Swap request dialog on My Schedule allows members to request swaps with optional reason. Service detail page shows swap approval list for team leads. Full swap lifecycle visible: request -> accept -> approve/reject with toast feedback and notification dispatch.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds
2. "Request Swap" button visible on My Schedule assignment cards
3. SwapRequestDialog opens and submits swap request
4. Eligible members receive swap_requested notification
5. Accepting a swap transitions to 'accepted' state and notifies team lead
6. Service detail page shows swap approval section for team leads
7. Approving a swap reassigns the member and notifies both parties
8. Rejecting a swap notifies both parties
9. Cancelling a pending swap request works from My Schedule
</verification>

<success_criteria>
- requestSwap validates ownership and checks no duplicate active swap
- acceptSwap uses atomic UPDATE to prevent race conditions on double-acceptance
- approveSwap verifies team lead authorization before executing the reassignment
- Swap state machine transitions: pending -> accepted -> approved/rejected, pending -> cancelled
- All swap events dispatch notifications to relevant parties
- UI components follow existing patterns (AlertDialog, useTransition, sonner toast)
</success_criteria>

<output>
After completion, create `.planning/phases/06-accept-decline-and-notifications/06-04-SUMMARY.md`
</output>
