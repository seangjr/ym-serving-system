---
phase: 06-accept-decline-and-notifications
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - components/notifications/notification-provider.tsx
  - components/notifications/notification-bell.tsx
  - components/notifications/notification-list.tsx
  - components/notifications/notification-item.tsx
  - app/(app)/layout.tsx
  - lib/assignments/actions.ts
  - components/app-sidebar.tsx
  - lib/auth/roles.ts
autonomous: true
requirements:
  - NOTF-01
  - NOTF-02
  - NOTF-04

must_haves:
  truths:
    - "Bell icon in app header shows unread notification count badge"
    - "Clicking bell opens a dropdown listing recent notifications"
    - "Notifications show read/unread visual distinction"
    - "New notifications appear in real-time via Supabase Realtime (no polling)"
    - "Assigning a member to a service creates a notification for that member"
    - "Unassigning a member creates a notification for that member"
  artifacts:
    - path: "components/notifications/notification-provider.tsx"
      provides: "React context + Supabase Realtime subscription for live notifications"
      min_lines: 40
    - path: "components/notifications/notification-bell.tsx"
      provides: "Bell icon button with unread count badge"
      min_lines: 20
    - path: "components/notifications/notification-list.tsx"
      provides: "Dropdown/popover listing notifications"
      min_lines: 40
    - path: "components/notifications/notification-item.tsx"
      provides: "Single notification row with read/unread styling"
      min_lines: 20
    - path: "lib/assignments/actions.ts"
      provides: "Modified assignMember and unassignMember to emit notifications"
  key_links:
    - from: "components/notifications/notification-provider.tsx"
      to: "lib/supabase/client.ts"
      via: "Supabase Realtime CDC subscription on notifications table"
      pattern: "postgres_changes.*notifications"
    - from: "components/notifications/notification-bell.tsx"
      to: "components/notifications/notification-provider.tsx"
      via: "useNotifications context for unread count"
      pattern: "useNotifications"
    - from: "lib/assignments/actions.ts"
      to: "lib/notifications/send.ts"
      via: "createNotification after assign/unassign"
      pattern: "createNotification"
    - from: "app/(app)/layout.tsx"
      to: "components/notifications/notification-provider.tsx"
      via: "NotificationProvider wrapping app content"
      pattern: "NotificationProvider"
---

<objective>
Build the in-app notification UI (bell icon, dropdown, read/unread state) with Supabase Realtime for live updates, and wire assignMember/unassignMember to emit notifications.

Purpose: Members need to see notifications when they are assigned to services. The bell icon with live unread count is the primary notification surface. This plan also adds the Bell icon to the sidebar ICON_MAP and fixes the CalendarOff icon bug (per research Pitfall 7).

Output: 4 notification UI components, Realtime subscription, assignment action modifications, sidebar icon fixes
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-accept-decline-and-notifications/06-RESEARCH.md
@.planning/phases/06-accept-decline-and-notifications/06-01-SUMMARY.md
@lib/notifications/types.ts
@lib/notifications/queries.ts
@lib/notifications/actions.ts
@lib/notifications/send.ts
@lib/assignments/actions.ts
@components/app-sidebar.tsx
@app/(app)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification UI components and Realtime provider</name>
  <files>
    components/notifications/notification-provider.tsx
    components/notifications/notification-bell.tsx
    components/notifications/notification-list.tsx
    components/notifications/notification-item.tsx
    app/(app)/layout.tsx
    components/app-sidebar.tsx
    lib/auth/roles.ts
  </files>
  <action>
**components/notifications/notification-provider.tsx** ("use client"):
- Create NotificationContext with: notifications (Notification[]), unreadCount (number), markRead (function), markAllRead (function), isLoading (boolean)
- `NotificationProvider` component:
  - Props: memberId (string), initialNotifications (Notification[]), initialUnreadCount (number)
  - State: notifications array, unreadCount
  - On mount: subscribe to Supabase Realtime CDC on `notifications` table filtered by `recipient_member_id=eq.${memberId}` (INSERT events only). Per research Pitfall 4, only use `eq` filter.
  - On new INSERT: prepend to notifications array, increment unreadCount, show toast via sonner (the notification title)
  - Cleanup: remove channel on unmount
  - `markRead(notificationId)`: call markAsRead server action, update local state optimistically (set is_read = true, decrement unreadCount)
  - `markAllRead()`: call markAllAsRead server action, update local state optimistically
- Export NotificationProvider and useNotifications hook

**components/notifications/notification-bell.tsx** ("use client"):
- Uses useNotifications context
- Renders a Button (variant="ghost", size="icon") with Bell icon from lucide-react
- If unreadCount > 0: show a small red badge with the count (absolute positioned, top-right of bell). Use min-w-5 h-5 rounded-full for the badge. Cap display at "99+" for large counts.
- Wraps a Popover (from shadcn/ui):
  - Trigger: the bell button
  - Content: NotificationList component
- Bell button placed in the app header area

**components/notifications/notification-list.tsx** ("use client"):
- Uses useNotifications context
- Header row: "Notifications" title + "Mark all as read" button (only shown if unreadCount > 0)
- Scrollable list of NotificationItem components (max-h-80 overflow-y-auto)
- If no notifications: show "No notifications yet" empty state
- At bottom: Link to "/notifications" for "View all" (for future full-page view)

**components/notifications/notification-item.tsx** ("use client"):
- Props: notification (Notification), onMarkRead callback
- Visual distinction for unread: bold text + left blue border (border-l-2 border-blue-500) vs normal for read
- Shows: title (font-medium), body (text-sm text-muted-foreground truncated to 2 lines), relative time (e.g., "2 hours ago" using formatDistanceToNow from date-fns)
- If has action_url: entire item is clickable (Link), marks as read on click
- If unread: show a small blue dot indicator on the right side

**app/(app)/layout.tsx** modifications:
- Import NotificationProvider
- Fetch the current user's memberId and initial notifications/unreadCount server-side
- Wrap page content with NotificationProvider, passing memberId, initial data
- Add NotificationBell to the header area (next to the sidebar trigger or in a fixed header bar). Place it in the top-right area of the main content panel. Use the existing header pattern if one exists, or add a thin header bar with the bell icon on the right side.
- Pass memberId as a prop (the layout is a server component, so fetch it there and pass to client wrapper)

**components/app-sidebar.tsx** modifications:
- Add `Bell` and `CalendarOff` to the lucide-react import
- Add `Bell` and `CalendarOff` to the ICON_MAP object
- This fixes research Pitfall 7 (CalendarOff was missing from ICON_MAP, causing fallback to Calendar)

**lib/auth/roles.ts** -- NO changes needed. The nav items already include CalendarOff icon string. The sidebar just needed the icon in ICON_MAP.
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Run `pnpm lint` to check for issues. Navigate to the app -- the bell icon should appear in the header. If there are notifications in the DB, they should appear in the dropdown. The CalendarOff icon should now render correctly for Availability nav item.</verify>
  <done>Bell icon appears in the app header with unread badge. Clicking opens a popover with notification list. Notifications show read/unread visual state. Supabase Realtime delivers new notifications without page refresh. CalendarOff icon bug is fixed.</done>
</task>

<task type="auto">
  <name>Task 2: Wire assignMember and unassignMember to emit notifications</name>
  <files>lib/assignments/actions.ts</files>
  <action>
Modify `lib/assignments/actions.ts` to emit notifications when members are assigned or unassigned.

**In assignMember():**
After the successful insert into service_assignments (after `if (error) return { error: error.message }`):
1. Look up the assigned member's name from the `members` table (parsed.data.memberId)
2. Look up the service title and date from `services` table (parsed.data.serviceId)
3. Look up the position name from `team_positions` via `service_positions` (parsed.data.servicePositionId)
4. Call createNotification():
   - recipientMemberId: parsed.data.memberId (the member being assigned)
   - type: 'assignment_new'
   - title: 'New Assignment'
   - body: 'You have been assigned as {positionName} for {serviceTitle} on {formattedDate}'
   - metadata: { serviceId: parsed.data.serviceId, assignmentId: (the newly created ID -- query it back), servicePositionId: parsed.data.servicePositionId }
   - actionUrl: '/my-schedule'
5. Use try/catch around the notification call so notification failure doesn't break the assignment

**Getting the new assignment ID:** After insert, query service_assignments for the row just inserted (by service_position_id which is unique). Or use `.select()` on the insert to get the ID back: `await admin.from("service_assignments").insert({...}).select("id").single()`.

**In unassignMember():**
Before deleting the assignment:
1. Query the assignment to get member_id, then get member name, service title, position name
2. After successful delete, call createNotification():
   - recipientMemberId: the member who was unassigned
   - type: 'assignment_changed'
   - title: 'Assignment Removed'
   - body: 'Your {positionName} assignment for {serviceTitle} has been removed'
   - metadata: { serviceId: parsed.data.serviceId }
   - actionUrl: '/my-schedule'
3. Use try/catch around notification call

Import `createNotification` from `@/lib/notifications/send` at the top of the file. Since this file is "use server", it can import server-only modules. Use dynamic import if needed: `const { createNotification } = await import("@/lib/notifications/send")`.
  </action>
  <verify>Run `pnpm build` to confirm no TypeScript errors. Assign a member to a service position via the service detail page. Check that a notification row is created in the notifications table for that member. Unassign them and verify another notification is created.</verify>
  <done>assignMember creates an 'assignment_new' notification for the assigned member. unassignMember creates an 'assignment_changed' notification for the unassigned member. Both use try/catch so notification failure doesn't block the primary action.</done>
</task>

</tasks>

<verification>
- `pnpm build` passes
- `pnpm lint` passes
- Bell icon visible in the app header for all users
- Unread count badge appears when notifications exist
- Clicking bell opens popover with notification list
- Unread notifications have visual distinction (bold + blue border/dot)
- "Mark all as read" clears the unread count
- Assigning a member creates an 'assignment_new' notification in the DB
- Unassigning a member creates an 'assignment_changed' notification in the DB
- New notifications appear in real-time (no page refresh needed)
- CalendarOff icon renders correctly for Availability nav item
</verification>

<success_criteria>
- NOTF-01 satisfied: system sends in-app notifications for new assignments and schedule changes
- NOTF-02 satisfied: notifications show read/unread state
- NOTF-04 satisfied: member receives notification when assigned to a service
- Live updates work via Supabase Realtime (no polling)
</success_criteria>

<output>
After completion, create `.planning/phases/06-accept-decline-and-notifications/06-03-SUMMARY.md`
</output>
