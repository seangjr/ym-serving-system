---
phase: 02-teams-and-member-profiles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00003_serving_teams.sql
  - supabase/migrations/00004_member_profiles.sql
  - lib/teams/schemas.ts
  - lib/teams/actions.ts
  - lib/teams/queries.ts
  - lib/profiles/schemas.ts
  - lib/profiles/actions.ts
  - lib/profiles/queries.ts
autonomous: true

must_haves:
  truths:
    - "serving_teams, team_positions, team_members, member_position_skills tables exist with correct schema and RLS policies"
    - "member_profiles table exists with 1:1 FK to members, RLS allows own-profile writes and all-authenticated reads"
    - "Supabase Storage avatars bucket exists and is public"
    - "Server actions for team CRUD, position CRUD, and member assignment enforce admin/committee/team-lead authorization"
    - "Server actions for profile updates use upsert pattern to handle existing members with no profile row"
    - "Query functions return teams with nested positions, members with nested team/skill data, and profiles with member info"
  artifacts:
    - path: "supabase/migrations/00003_serving_teams.sql"
      provides: "serving_teams, team_positions, team_members, member_position_skills tables + RLS"
      contains: "create table public.serving_teams"
    - path: "supabase/migrations/00004_member_profiles.sql"
      provides: "member_profiles table + avatars storage bucket + RLS"
      contains: "create table public.member_profiles"
    - path: "lib/teams/actions.ts"
      provides: "Team/position/membership server actions"
      exports: ["createTeam", "updateTeam", "deleteTeam", "createPosition", "updatePosition", "deletePosition", "addMemberToTeam", "removeMemberFromTeam", "updateMemberTeamRole", "updateMemberPositionSkill"]
    - path: "lib/teams/queries.ts"
      provides: "Team query functions"
      exports: ["getTeams", "getTeamWithMembers", "getTeamPositions"]
    - path: "lib/teams/schemas.ts"
      provides: "Zod validation schemas for teams/positions"
      exports: ["createTeamSchema", "updateTeamSchema", "createPositionSchema", "updatePositionSchema"]
    - path: "lib/profiles/actions.ts"
      provides: "Profile server actions"
      exports: ["updateOwnProfile", "updateNotificationPreferences", "uploadAvatar"]
    - path: "lib/profiles/queries.ts"
      provides: "Profile query functions"
      exports: ["getOwnProfile", "getMemberProfile"]
    - path: "lib/profiles/schemas.ts"
      provides: "Zod validation schemas for profiles"
      exports: ["updateProfileSchema", "notificationPreferencesSchema"]
  key_links:
    - from: "lib/teams/actions.ts"
      to: "lib/auth/roles.ts"
      via: "getUserRole() for authorization"
      pattern: "getUserRole\\(supabase\\)"
    - from: "lib/teams/actions.ts"
      to: "lib/supabase/admin.ts"
      via: "createAdminClient() for writes"
      pattern: "createAdminClient\\(\\)"
    - from: "lib/profiles/actions.ts"
      to: "lib/auth/roles.ts"
      via: "getUserRole() to get memberId"
      pattern: "getUserRole\\(supabase\\)"
    - from: "lib/teams/queries.ts"
      to: "lib/supabase/server.ts"
      via: "createClient() for RLS-protected reads"
      pattern: "createClient\\(\\)"
---

<objective>
Create the complete database schema for teams, positions, membership, skills, and member profiles, then implement all server actions and query functions that the UI plans will consume.

Purpose: Establish the data foundation and business logic layer for Phase 2 so that UI plans (02-02, 02-03, 02-04) can build pages without worrying about data access patterns.

Output: Two SQL migration files, six TypeScript modules (actions, queries, schemas for teams and profiles), and a Supabase Storage avatars bucket.
</objective>

<execution_context>
@/Users/chungweijian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chungweijian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-teams-and-member-profiles/02-RESEARCH.md
@lib/auth/roles.ts
@lib/auth/admin-actions.ts
@lib/supabase/admin.ts
@lib/supabase/server.ts
@lib/auth/schemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migrations for teams, positions, membership, skills, and profiles</name>
  <files>
    supabase/migrations/00003_serving_teams.sql
    supabase/migrations/00004_member_profiles.sql
  </files>
  <action>
Create two SQL migration files following the schema from 02-RESEARCH.md.

**00003_serving_teams.sql** — Create these tables in order:

1. `public.serving_teams` — id (uuid PK, gen_random_uuid), name (text NOT NULL UNIQUE), description (text), color (text, hex for UI), is_active (boolean NOT NULL DEFAULT true), sort_order (int NOT NULL DEFAULT 0), created_at (timestamptz NOT NULL DEFAULT now()), updated_at (timestamptz NOT NULL DEFAULT now()).

2. `public.team_positions` — id (uuid PK, gen_random_uuid), team_id (uuid NOT NULL FK -> serving_teams ON DELETE CASCADE), name (text NOT NULL), category (text — free-form, NOT an enum, e.g. "vocals", "instruments", "production"), quantity_needed (int NOT NULL DEFAULT 1), sort_order (int NOT NULL DEFAULT 0), is_active (boolean NOT NULL DEFAULT true), created_at (timestamptz NOT NULL DEFAULT now()). UNIQUE(team_id, name).

3. `public.team_members` — id (uuid PK, gen_random_uuid), team_id (uuid NOT NULL FK -> serving_teams ON DELETE CASCADE), member_id (uuid NOT NULL FK -> members ON DELETE CASCADE), role (text NOT NULL DEFAULT 'member' CHECK role IN ('lead', 'member')), joined_at (timestamptz NOT NULL DEFAULT now()). UNIQUE(team_id, member_id).

4. `public.member_position_skills` — id (uuid PK, gen_random_uuid), member_id (uuid NOT NULL FK -> members ON DELETE CASCADE), position_id (uuid NOT NULL FK -> team_positions ON DELETE CASCADE), proficiency (text NOT NULL DEFAULT 'beginner' CHECK IN ('beginner', 'intermediate', 'advanced', 'expert')), preference (text NOT NULL DEFAULT 'willing' CHECK IN ('primary', 'secondary', 'willing')), created_at (timestamptz NOT NULL DEFAULT now()). UNIQUE(member_id, position_id).

5. Enable RLS on all four tables. Add SELECT policy for `authenticated` role with `using (true)` on all four tables. No INSERT/UPDATE/DELETE RLS policies — writes go through admin client.

6. Add `updated_at` trigger for `serving_teams` — create a trigger function `update_updated_at_column()` if not exists, then attach it to `serving_teams` BEFORE UPDATE.

**00004_member_profiles.sql** — Create:

1. `public.member_profiles` — member_id (uuid PK FK -> members ON DELETE CASCADE), phone (text), avatar_url (text), emergency_contact_name (text), emergency_contact_phone (text), birthdate (date), joined_serving_at (timestamptz DEFAULT now()), notify_email (boolean NOT NULL DEFAULT true), notify_assignment_changes (boolean NOT NULL DEFAULT true), reminder_days_before (int NOT NULL DEFAULT 2), updated_at (timestamptz NOT NULL DEFAULT now()).

2. Enable RLS. Add SELECT policy for authenticated with `using (true)`. Add UPDATE policy for authenticated with `using (member_id IN (SELECT id FROM public.members WHERE auth_user_id = (SELECT auth.uid())))`. Add INSERT policy for authenticated with `with check (member_id IN (SELECT id FROM public.members WHERE auth_user_id = (SELECT auth.uid())))`.

3. Attach `update_updated_at_column()` trigger to `member_profiles` BEFORE UPDATE.

4. Create Supabase Storage bucket: `INSERT INTO storage.buckets (id, name, public) VALUES ('avatars', 'avatars', true) ON CONFLICT (id) DO NOTHING;`. Add storage policy for authenticated users to upload to their own folder: `CREATE POLICY "Users can upload own avatar" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'avatars' AND (storage.foldername(name))[1] = (SELECT m.id::text FROM public.members m WHERE m.auth_user_id = (SELECT auth.uid())));`. Add public SELECT policy on avatars bucket for all: `CREATE POLICY "Avatar images are publicly accessible" ON storage.objects FOR SELECT TO public USING (bucket_id = 'avatars');`. Add UPDATE policy for own avatar: `CREATE POLICY "Users can update own avatar" ON storage.objects FOR UPDATE TO authenticated USING (bucket_id = 'avatars' AND (storage.foldername(name))[1] = (SELECT m.id::text FROM public.members m WHERE m.auth_user_id = (SELECT auth.uid())));`.

**IMPORTANT:** Position categories are free-form text, NOT enums. Do NOT create any Postgres enum types. This ensures ministry-agnostic flexibility (TEAM-05).
  </action>
  <verify>
Check that both SQL files parse correctly:
```bash
# Verify SQL syntax is valid (no bash parsing, just check file exists and has expected tables)
grep -c "create table" supabase/migrations/00003_serving_teams.sql  # should be 4
grep -c "create table" supabase/migrations/00004_member_profiles.sql  # should be 1
grep -c "enable row level security" supabase/migrations/00003_serving_teams.sql  # should be 4
grep -c "enable row level security" supabase/migrations/00004_member_profiles.sql  # should be 1
grep -c "storage.buckets" supabase/migrations/00004_member_profiles.sql  # should be 1
```
  </verify>
  <done>All five tables (serving_teams, team_positions, team_members, member_position_skills, member_profiles) defined with correct columns, constraints, FK relationships, RLS policies, and updated_at triggers. Avatars storage bucket created with appropriate policies. No Postgres enum types used for categories or proficiency.</done>
</task>

<task type="auto">
  <name>Task 2: Zod schemas, server actions, and query functions for teams and positions</name>
  <files>
    lib/teams/schemas.ts
    lib/teams/actions.ts
    lib/teams/queries.ts
  </files>
  <action>
Create the teams module following established patterns from `lib/auth/admin-actions.ts` and `lib/auth/schemas.ts`.

**lib/teams/schemas.ts:**
- `createTeamSchema`: name (string, min 1 "Team name is required", max 100), description (string, max 500, optional), color (string, regex /^#[0-9a-fA-F]{6}$/ "Must be a hex color", optional).
- `updateTeamSchema`: same as create but all fields optional, plus id (string, uuid).
- `createPositionSchema`: teamId (string, uuid), name (string, min 1, max 100), category (string, max 50, optional), quantityNeeded (number, int, min 1, max 20, default 1).
- `updatePositionSchema`: id (string, uuid), name (string, min 1, max 100, optional), category (string, max 50, optional), quantityNeeded (number, int, min 1, max 20, optional), sortOrder (number, int, min 0, optional), isActive (boolean, optional).
- `proficiencyLevels` as const: ["beginner", "intermediate", "advanced", "expert"].
- `preferenceLevels` as const: ["primary", "secondary", "willing"].
- Export TypeScript types for each schema using `z.infer`.

**lib/teams/actions.ts:**
Add `"use server"` directive. Import getUserRole, createAdminClient, createClient, revalidatePath, and schemas.

Actions (all follow the pattern: verify auth role -> validate input -> admin client write -> revalidatePath -> return { success } or { error }):

1. `createTeam(data)` — Admin/committee only. Insert into serving_teams. Return { success: true, teamId }.
2. `updateTeam(data)` — Admin/committee only. Update serving_teams by id. revalidatePath("/teams").
3. `deleteTeam(teamId: string)` — Admin only. Delete from serving_teams (cascade handles positions, members). revalidatePath("/teams").
4. `createPosition(data)` — Admin/committee only. Insert into team_positions. revalidatePath for the team.
5. `updatePosition(data)` — Admin/committee only. Update team_positions by id. revalidatePath for the team.
6. `deletePosition(positionId: string)` — Admin/committee only. Delete from team_positions. revalidatePath for the team.
7. `addMemberToTeam(teamId, memberId, role = "member")` — Admin/committee OR team lead of that team (check team_members for lead role). Upsert into team_members. revalidatePath for the team.
8. `removeMemberFromTeam(teamId, memberId)` — Admin/committee OR team lead of that team. Delete from team_members. revalidatePath for the team.
9. `updateMemberTeamRole(teamId, memberId, newRole: "lead" | "member")` — Admin/committee only (not team leads — they can't promote others). Update team_members.role. revalidatePath for the team.
10. `updateMemberPositionSkill(memberId, positionId, proficiency, preference)` — Admin/committee OR team lead of the position's team. Upsert into member_position_skills. revalidatePath for the team.

**Authorization pattern for team lead check** (used in addMemberToTeam, removeMemberFromTeam, updateMemberPositionSkill):
```typescript
if (!isAdminOrCommittee(userRole)) {
  const { data: callerMembership } = await admin
    .from("team_members")
    .select("role")
    .eq("team_id", teamId)
    .eq("member_id", callerMemberId)
    .single();
  if (callerMembership?.role !== "lead") {
    return { error: "Unauthorized" };
  }
}
```

**lib/teams/queries.ts:**
Import createClient from server.ts. All reads use the RLS-protected client (not admin).

1. `getTeams()` — Select from serving_teams with nested team_positions count and team_members count. Order by sort_order, name. Filter is_active = true.
2. `getTeamWithMembers(teamId: string)` — Select serving_teams by id with nested: team_positions (all), team_members with nested members (full_name, email) and member_profiles (phone, avatar_url). Also include member_position_skills for members in this team.
3. `getTeamPositions(teamId: string)` — Select team_positions where team_id = teamId, ordered by sort_order.
4. `getAllMembers(searchQuery?: string)` — For member assignment combobox. Select from members (id, full_name, email) with optional ilike filter on full_name or email. Order by full_name.

Return proper TypeScript types for all query results.
  </action>
  <verify>
```bash
# Check file exists and has expected exports
grep -c "export async function" lib/teams/actions.ts   # should be 10
grep -c "export async function" lib/teams/queries.ts   # should be 4
grep -c "export const" lib/teams/schemas.ts             # should be >= 4 (schemas)
# Lint check
pnpm lint 2>&1 | tail -5
```
  </verify>
  <done>Teams module has 10 server actions with proper auth checks (admin/committee for CRUD, team-lead for membership), 4 query functions with nested selects, and Zod schemas for all input validation. All actions use admin client for writes. All queries use RLS-protected client. Types are exported for UI consumption.</done>
</task>

<task type="auto">
  <name>Task 3: Zod schemas, server actions, and query functions for member profiles</name>
  <files>
    lib/profiles/schemas.ts
    lib/profiles/actions.ts
    lib/profiles/queries.ts
  </files>
  <action>
Create the profiles module following the same established patterns.

**lib/profiles/schemas.ts:**
- `updateProfileSchema`: phone (string, max 20, optional or empty string), emergency_contact_name (string, max 100, optional), emergency_contact_phone (string, max 20, optional), birthdate (string date format, optional — use z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional().or(z.literal("")) for flexible handling).
- `notificationPreferencesSchema`: notify_email (boolean), notify_assignment_changes (boolean), reminder_days_before (number, int, min 0, max 14).
- Export TypeScript types.

**lib/profiles/actions.ts:**
Add `"use server"` directive.

1. `updateOwnProfile(data)` — Any authenticated user. Get memberId from getUserRole. Validate with updateProfileSchema. Use admin client to upsert into member_profiles (onConflict: "member_id"). Set updated_at to new Date().toISOString(). revalidatePath("/profile"). Return { success } or { error }.

2. `updateNotificationPreferences(data)` — Any authenticated user. Get memberId from getUserRole. Validate with notificationPreferencesSchema. Admin client upsert into member_profiles (only the notification fields + member_id + updated_at). revalidatePath("/profile").

3. `updateAvatarUrl(avatarUrl: string)` — Any authenticated user. Get memberId from getUserRole. Admin client upsert member_profiles with { member_id, avatar_url: avatarUrl, updated_at }. revalidatePath("/profile"). (The actual file upload happens client-side via Supabase Storage SDK; this action just saves the URL.)

4. `adminUpdateMemberProfile(memberId: string, data)` — Admin/committee only. Validate role. Admin client upsert into member_profiles for the given memberId. revalidatePath for the member. (For admin/team lead adding profile info when adding members — PROF-01.)

**lib/profiles/queries.ts:**
Import createClient from server.ts.

1. `getOwnProfile()` — Get current user's memberId via getUserRole. Select from members (id, full_name, email) with nested member_profiles (all columns). Return profile data or null. Handle the "no profile yet" case by returning the member data with null profile fields.

2. `getMemberProfile(memberId: string)` — Select from members by id with nested member_profiles, team_members with nested serving_teams, and member_position_skills with nested team_positions. Returns name, positions, contact info, teams. For PROF-06 (viewing other members).

3. `getMembersByTeam(teamId: string)` — Select from team_members where team_id with nested members (full_name, email), member_profiles (phone, avatar_url), and member_position_skills with nested team_positions. For team detail views.
  </action>
  <verify>
```bash
grep -c "export async function" lib/profiles/actions.ts   # should be 4
grep -c "export async function" lib/profiles/queries.ts   # should be 3
grep -c "export const" lib/profiles/schemas.ts             # should be >= 2
pnpm lint 2>&1 | tail -5
```
  </verify>
  <done>Profiles module has 4 server actions (own profile, notification prefs, avatar URL, admin update), 3 query functions (own profile, member profile, team members), and Zod schemas. Upsert pattern handles existing 350+ members with no profile rows. Avatar URL stored after client-side upload.</done>
</task>

</tasks>

<verification>
After all three tasks are complete:
1. `pnpm build` passes (TypeScript compiles, no type errors)
2. `pnpm lint` passes (Biome linting clean)
3. Both migration files exist with correct table definitions
4. All server action files have `"use server"` directive
5. All query files use `createClient()` (RLS-protected), all actions use `createAdminClient()` for writes
6. No Postgres enum types created (ministry-agnostic principle)
7. Team lead authorization checks query team_members table for lead role (not global roles table)
</verification>

<success_criteria>
- 5 new database tables defined with proper FKs, constraints, and RLS policies
- 1 Supabase Storage bucket (avatars) with upload/read policies
- 14 server actions across 2 modules with proper authorization
- 7 query functions across 2 modules with nested selects
- 6+ Zod validation schemas
- All TypeScript types exported for UI plan consumption
- `pnpm build` and `pnpm lint` pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-teams-and-member-profiles/02-01-SUMMARY.md`
</output>
